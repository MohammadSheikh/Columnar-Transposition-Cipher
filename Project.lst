Microsoft (R) Macro Assembler Version 14.22.27905.0	    01/23/20 14:19:56
final_project.asm					     Page 1 - 1


				;CS66 Final Project
				INCLUDE irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 

 00000000			.data
 00000000 0D 0A 0D 0A			msg0_1 BYTE 0Dh,0Ah,0Dh,0Ah
 00000004  2A 2A 2A 2A 2A			   BYTE "********************************************",0Dh,0Ah
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 0D
	   0A
 00000032  20 20 43 6F 6C			   BYTE "  Columnar Transposition Cipher Encryption  ",0Dh,0Ah
	   75 6D 6E 61 72
	   20 54 72 61 6E
	   73 70 6F 73 69
	   74 69 6F 6E 20
	   43 69 70 68 65
	   72 20 45 6E 63
	   72 79 70 74 69
	   6F 6E 20 20 0D
	   0A
 00000060  2A 2A 2A 2A 2A			   BYTE "********************************************",0Dh,0Ah,0Dh,0Ah
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 2A 0D
	   0A 0D 0A
 00000090  50 6C 65 61 73			   BYTE "Please select from one of the following options:",0Dh,0Ah,0Dh,0Ah
	   65 20 73 65 6C
	   65 63 74 20 66
	   72 6F 6D 20 6F
	   6E 65 20 6F 66
	   20 74 68 65 20
	   66 6F 6C 6C 6F
	   77 69 6E 67 20
	   6F 70 74 69 6F
	   6E 73 3A 0D 0A
	   0D 0A
 000000C4  31 2E 20 45 6E			   BYTE "1. Encryption a text",0Dh,0Ah,0Dh,0Ah
	   63 72 79 70 74
	   69 6F 6E 20 61
	   20 74 65 78 74
	   0D 0A 0D 0A
 000000DC  32 2E 20 44 65	           BYTE "2. Decryption a text",0Dh,0Ah,0Dh,0Ah
	   63 72 79 70 74
	   69 6F 6E 20 61
	   20 74 65 78 74
	   0D 0A 0D 0A
 000000F4  33 2E 20 42 72			   BYTE "3. Brute-force key guessing (please run encrypt the first text)",0Dh,0Ah
	   75 74 65 2D 66
	   6F 72 63 65 20
	   6B 65 79 20 67
	   75 65 73 73 69
	   6E 67 20 28 70
	   6C 65 61 73 65
	   20 72 75 6E 20
	   65 6E 63 72 79
	   70 74 20 74 68
	   65 20 66 69 72
	   73 74 20 74 65
	   78 74 29 0D 0A
 00000135  20 20 20 20 20			   BYTE "     - Please run encryption on <US Constitution - 14th Amendment> in Option 1 first",0Dh,0Ah
	   2D 20 50 6C 65
	   61 73 65 20 72
	   75 6E 20 65 6E
	   63 72 79 70 74
	   69 6F 6E 20 6F
	   6E 20 3C 55 53
	   20 43 6F 6E 73
	   74 69 74 75 74
	   69 6F 6E 20 2D
	   20 31 34 74 68
	   20 41 6D 65 6E
	   64 6D 65 6E 74
	   3E 20 69 6E 20
	   4F 70 74 69 6F
	   6E 20 31 20 66
	   69 72 73 74 0D
	   0A
 0000018B  20 20 20 20 20			   BYTE "     - Due to the property of Columnar Transposition Cipher:",0Dh,0Ah
	   2D 20 44 75 65
	   20 74 6F 20 74
	   68 65 20 70 72
	   6F 70 65 72 74
	   79 20 6F 66 20
	   43 6F 6C 75 6D
	   6E 61 72 20 54
	   72 61 6E 73 70
	   6F 73 69 74 69
	   6F 6E 20 43 69
	   70 68 65 72 3A
	   0D 0A
 000001C9  20 20 20 20 20			   BYTE "          1. There are more than 1 keys that are able to decrypt.",0Dh,0Ah
	   20 20 20 20 20
	   31 2E 20 54 68
	   65 72 65 20 61
	   72 65 20 6D 6F
	   72 65 20 74 68
	   61 6E 20 31 20
	   6B 65 79 73 20
	   74 68 61 74 20
	   61 72 65 20 61
	   62 6C 65 20 74
	   6F 20 64 65 63
	   72 79 70 74 2E
	   0D 0A
 0000020C  20 20 20 20 20			   BYTE "          2. Brute-force method will find the smallest key to decrypt.",0Dh,0Ah
	   20 20 20 20 20
	   32 2E 20 42 72
	   75 74 65 2D 66
	   6F 72 63 65 20
	   6D 65 74 68 6F
	   64 20 77 69 6C
	   6C 20 66 69 6E
	   64 20 74 68 65
	   20 73 6D 61 6C
	   6C 65 73 74 20
	   6B 65 79 20 74
	   6F 20 64 65 63
	   72 79 70 74 2E
	   0D 0A
 00000254  20 20 20 20 20			   BYTE "          3. Keys will appear as numbers.",0Dh,0Ah
	   20 20 20 20 20
	   33 2E 20 4B 65
	   79 73 20 77 69
	   6C 6C 20 61 70
	   70 65 61 72 20
	   61 73 20 6E 75
	   6D 62 65 72 73
	   2E 0D 0A
 0000027F  20 20 20 20 20			   BYTE "     - After it's done, use the cracked key in Option 2 to test it.",0Dh,0Ah,0Dh,0Ah
	   2D 20 41 66 74
	   65 72 20 69 74
	   27 73 20 64 6F
	   6E 65 2C 20 75
	   73 65 20 74 68
	   65 20 63 72 61
	   63 6B 65 64 20
	   6B 65 79 20 69
	   6E 20 4F 70 74
	   69 6F 6E 20 32
	   20 74 6F 20 74
	   65 73 74 20 69
	   74 2E 0D 0A 0D
	   0A
 000002C6  30 2E 20 45 78			   BYTE "0. Exit",0Dh,0Ah,0Dh,0Ah
	   69 74 0D 0A 0D
	   0A
 000002D1  2D 3E 20 00				   BYTE "-> ",0
 000002D5 0D 0A 0D 0A 52		msg0_2 BYTE 0Dh,0Ah,0Dh,0Ah,"Rerun? y/n ",0
	   65 72 75 6E 3F
	   20 79 2F 6E 20
	   00

				;Part 1 Encryption
 000002E5 0D 0A 0D 0A 50	    msg1_0 BYTE 0Dh,0Ah,0Dh,0Ah,"Please enter the length of your key (5 to 10): ",0
	   6C 65 61 73 65
	   20 65 6E 74 65
	   72 20 74 68 65
	   20 6C 65 6E 67
	   74 68 20 6F 66
	   20 79 6F 75 72
	   20 6B 65 79 20
	   28 35 20 74 6F
	   20 31 30 29 3A
	   20 00
 00000319 0D 0A 0D 0A 44		msg1_1 BYTE 0Dh,0Ah,0Dh,0Ah,"Does your key contain numbers (0-9)? y/n ",0	        ;10
	   6F 65 73 20 79
	   6F 75 72 20 6B
	   65 79 20 63 6F
	   6E 74 61 69 6E
	   20 6E 75 6D 62
	   65 72 73 20 28
	   30 2D 39 29 3F
	   20 79 2F 6E 20
	   00
 00000347 0D 0A 0D 0A 44		msg1_2 BYTE 0Dh,0Ah,0Dh,0Ah,"Does your key contain lowercase letters (a-z)? y/n ",0	;26
	   6F 65 73 20 79
	   6F 75 72 20 6B
	   65 79 20 63 6F
	   6E 74 61 69 6E
	   20 6C 6F 77 65
	   72 63 61 73 65
	   20 6C 65 74 74
	   65 72 73 20 28
	   61 2D 7A 29 3F
	   20 79 2F 6E 20
	   00
 0000037F 0D 0A 0D 0A 44		msg1_3 BYTE 0Dh,0Ah,0Dh,0Ah,"Does your key contain uppercase letters (A-Z)? y/n ",0	;26
	   6F 65 73 20 79
	   6F 75 72 20 6B
	   65 79 20 63 6F
	   6E 74 61 69 6E
	   20 75 70 70 65
	   72 63 61 73 65
	   20 6C 65 74 74
	   65 72 73 20 28
	   41 2D 5A 29 3F
	   20 79 2F 6E 20
	   00
 000003B7 0D 0A 0D 0A 47	    msg1_4 BYTE 0Dh,0Ah,0Dh,0Ah,"Generated key: ",0
	   65 6E 65 72 61
	   74 65 64 20 6B
	   65 79 3A 20 00
 000003CB 0D 0A 41 63 63	    msg1_5 BYTE 0Dh,0Ah,"Accept? y/n ",0
	   65 70 74 3F 20
	   79 2F 6E 20 00
 000003DA 0D 0A 0D 0A		    msg1_6 BYTE 0Dh,0Ah,0Dh,0Ah
 000003DE  2D 2D 2D 2D 2D			   BYTE "---------------Encrypt A Text---------------",0Dh,0Ah
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   45 6E 63 72 79
	   70 74 20 41 20
	   54 65 78 74 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 0D
	   0A
 0000040C  0D 0A 00				   BYTE 0Dh,0Ah,0
 0000040F 50 6C 65 61 73		msg1_11 BYTE "Please select from the following texts:",0Dh,0Ah,0Dh,0Ah
	   65 20 73 65 6C
	   65 63 74 20 66
	   72 6F 6D 20 74
	   68 65 20 66 6F
	   6C 6C 6F 77 69
	   6E 67 20 74 65
	   78 74 73 3A 0D
	   0A 0D 0A
 0000043A  31 2E 20 55 53			   BYTE "1. US Constitution - 14th Amendment",0Dh,0Ah,0Dh,0Ah
	   20 43 6F 6E 73
	   74 69 74 75 74
	   69 6F 6E 20 2D
	   20 31 34 74 68
	   20 41 6D 65 6E
	   64 6D 65 6E 74
	   0D 0A 0D 0A
 00000461  32 2E 20 4C 61			   BYTE "2. Last section of <The Last Question>",0Dh,0Ah,0Dh,0Ah
	   73 74 20 73 65
	   63 74 69 6F 6E
	   20 6F 66 20 3C
	   54 68 65 20 4C
	   61 73 74 20 51
	   75 65 73 74 69
	   6F 6E 3E 0D 0A
	   0D 0A
 0000048B  33 2E 20 4C 65			   BYTE "3. Lebron James the hypocrite",0Dh,0Ah,0Dh,0Ah
	   62 72 6F 6E 20
	   4A 61 6D 65 73
	   20 74 68 65 20
	   68 79 70 6F 63
	   72 69 74 65 0D
	   0A 0D 0A
 000004AC  30 2E 20 52 65			   BYTE "0. Return",0Dh,0Ah,0Dh,0Ah
	   74 75 72 6E 0D
	   0A 0D 0A
 000004B9  2D 3E 20 00				   BYTE "-> ",0
 000004BD 0D 0A 0D 0A 54	    msg1_7 BYTE 0Dh,0Ah,0Dh,0Ah,"This is the original text:",0
	   68 69 73 20 69
	   73 20 74 68 65
	   20 6F 72 69 67
	   69 6E 61 6C 20
	   74 65 78 74 3A
	   00
 000004DC 0D 0A 0D 0A 54	    msg1_8 BYTE 0Dh,0Ah,0Dh,0Ah,"This is the encrypted text:",0
	   68 69 73 20 69
	   73 20 74 68 65
	   20 65 6E 63 72
	   79 70 74 65 64
	   20 74 65 78 74
	   3A 00
 000004FC 0D 0A 0D 0A 45	    msg1_9 BYTE 0Dh,0Ah,0Dh,0Ah,"Encrypted text saved to: encrypted_text.txt",0Dh,0Ah,0Dh,0Ah,0
	   6E 63 72 79 70
	   74 65 64 20 74
	   65 78 74 20 73
	   61 76 65 64 20
	   74 6F 3A 20 65
	   6E 63 72 79 70
	   74 65 64 5F 74
	   65 78 74 2E 74
	   78 74 0D 0A 0D
	   0A 00
 00000530 0D 0A 0D 0A 45		msg1_10 BYTE 0Dh,0Ah,0Dh,0Ah,"Enter your own key? y/n ",0
	   6E 74 65 72 20
	   79 6F 75 72 20
	   6F 77 6E 20 6B
	   65 79 3F 20 79
	   2F 6E 20 00

 0000054D 0D 0A 0D 0A 49	    err1_0 BYTE 0Dh,0Ah,0Dh,0Ah,"Invalid length!",0
	   6E 76 61 6C 69
	   64 20 6C 65 6E
	   67 74 68 21 00
 00000561 0D 0A 0D 0A 45	    err1_1 BYTE 0Dh,0Ah,0Dh,0Ah,"Empty key!",0
	   6D 70 74 79 20
	   6B 65 79 21 00
 00000570 0D 0A 0D 0A 49	    err1_2 BYTE 0Dh,0Ah,0Dh,0Ah,"Invalid selection!",0
	   6E 76 61 6C 69
	   64 20 73 65 6C
	   65 63 74 69 6F
	   6E 21 00

				;Part 2 Decryption
 00000587 0D 0A 0D 0A			msg2_0 BYTE 0Dh,0Ah,0Dh,0Ah
 0000058B  2D 2D 2D 2D 2D			   BYTE "---------------Decrypt A Text---------------",0Dh,0Ah		   
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   44 65 63 72 79
	   70 74 20 41 20
	   54 65 78 74 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 0D
	   0A
 000005B9  0D 0A 00				   BYTE 0Dh,0Ah,0
 000005BC 5B 65 6E 63 72		msg2_6 BYTE "[encrypted_text.txt loaded]",0Dh,0Ah,0Dh,0Ah,0
	   79 70 74 65 64
	   5F 74 65 78 74
	   2E 74 78 74 20
	   6C 6F 61 64 65
	   64 5D 0D 0A 0D
	   0A 00
 000005DC 50 6C 65 61 73		msg2_5 BYTE "Please select from the following options:",0Dh,0Ah,0Dh,0Ah
	   65 20 73 65 6C
	   65 63 74 20 66
	   72 6F 6D 20 74
	   68 65 20 66 6F
	   6C 6C 6F 77 69
	   6E 67 20 6F 70
	   74 69 6F 6E 73
	   3A 0D 0A 0D 0A
 00000609  31 2E 20 44 65			   BYTE "1. Decrypt using existing key from previous entries",0Dh,0Ah,0Dh,0Ah
	   63 72 79 70 74
	   20 75 73 69 6E
	   67 20 65 78 69
	   73 74 69 6E 67
	   20 6B 65 79 20
	   66 72 6F 6D 20
	   70 72 65 76 69
	   6F 75 73 20 65
	   6E 74 72 69 65
	   73 0D 0A 0D 0A
 00000640  32 2E 20 45 6E			   BYTE "2. Enter a key",0Dh,0Ah,0Dh,0Ah
	   74 65 72 20 61
	   20 6B 65 79 0D
	   0A 0D 0A
 00000652  30 2E 20 52 65			   BYTE "0. Return",0Dh,0Ah,0Dh,0Ah
	   74 75 72 6E 0D
	   0A 0D 0A
 0000065F  2D 3E 20 00				   BYTE "-> ",0
 00000663 0D 0A 0D 0A 54		msg2_1 BYTE 0Dh,0Ah,0Dh,0Ah,"This is the decrypted text:",0
	   68 69 73 20 69
	   73 20 74 68 65
	   20 64 65 63 72
	   79 70 74 65 64
	   20 74 65 78 74
	   3A 00
 00000683 0D 0A 0D 0A 44	    msg2_2 BYTE 0Dh,0Ah,0Dh,0Ah,"Decrypted text saved to: decrypted_text.txt",0Dh,0Ah,0Dh,0Ah,0
	   65 63 72 79 70
	   74 65 64 20 74
	   65 78 74 20 73
	   61 76 65 64 20
	   74 6F 3A 20 64
	   65 63 72 79 70
	   74 65 64 5F 74
	   65 78 74 2E 74
	   78 74 0D 0A 0D
	   0A 00
 000006B7 0D 0A 50 6C 65		msg2_3 BYTE 0Dh,0Ah,"Please enter a key between 5 - 10 characters (uppercase/lowercase/numbers): ",0
	   61 73 65 20 65
	   6E 74 65 72 20
	   61 20 6B 65 79
	   20 62 65 74 77
	   65 65 6E 20 35
	   20 2D 20 31 30
	   20 63 68 61 72
	   61 63 74 65 72
	   73 20 28 75 70
	   70 65 72 63 61
	   73 65 2F 6C 6F
	   77 65 72 63 61
	   73 65 2F 6E 75
	   6D 62 65 72 73
	   29 3A 20 00
 00000706 0D 0A 4B 65 79		msg2_4 BYTE 0Dh,0Ah,"Key saved: ",0
	   20 73 61 76 65
	   64 3A 20 00

 00000714 0D 0A 0D 0A			err2_0 BYTE 0Dh,0Ah,0Dh,0Ah
 00000718  4B 65 79 20 69			   BYTE "Key is too short!",0Dh,0Ah,0
	   73 20 74 6F 6F
	   20 73 68 6F 72
	   74 21 0D 0A 00

				;Part 3 Brute Force
 0000072C 0D 0A 0D 0A			msg3_0 BYTE 0Dh,0Ah,0Dh,0Ah
 00000730  2D 2D 2D 2D 2D			   BYTE "---------------Brute Force---------------",0Dh,0Ah		   
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   42 72 75 74 65
	   20 46 6F 72 63
	   65 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 0D 0A
 0000075B  0D 0A 00				   BYTE 0Dh,0Ah,0
 0000075E 5B 55 73 69 6E		msg3_1 BYTE "[Using <US Constitution - 14th Amendment> as Original Text]",0Dh,0Ah,0Dh,0Ah
	   67 20 3C 55 53
	   20 43 6F 6E 73
	   74 69 74 75 74
	   69 6F 6E 20 2D
	   20 31 34 74 68
	   20 41 6D 65 6E
	   64 6D 65 6E 74
	   3E 20 61 73 20
	   4F 72 69 67 69
	   6E 61 6C 20 54
	   65 78 74 5D 0D
	   0A 0D 0A
 0000079D  5B 65 6E 63 72			   BYTE "[encrypted_text.txt loaded as Encrypted Text]",0Dh,0Ah,0Dh,0Ah,0
	   79 70 74 65 64
	   5F 74 65 78 74
	   2E 74 78 74 20
	   6C 6F 61 64 65
	   64 20 61 73 20
	   45 6E 63 72 79
	   70 74 65 64 20
	   54 65 78 74 5D
	   0D 0A 0D 0A 00
 000007CF 20 20 20 20 20		msg3_2 BYTE "                  _________       __[__]__                                   ",0Dh,0Ah
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 5F 5F
	   5F 5F 5F 5F 5F
	   5F 5F 20 20 20
	   20 20 20 20 5F
	   5F 5B 5F 5F 5D
	   5F 5F 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 0D 0A
 0000081E  20 20 20 20 20			   BYTE "                 |__|___|__|       (o_o )                                    ",0Dh,0Ah
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 7C 5F 5F
	   7C 5F 5F 5F 7C
	   5F 5F 7C 20 20
	   20 20 20 20 20
	   28 6F 5F 6F 20
	   29 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 0D 0A
 0000086D  20 20 20 20 20			   BYTE "                 |____|____|         |     o   ___________________________   ",0Dh,0Ah
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 7C 5F 5F
	   5F 5F 7C 5F 5F
	   5F 5F 7C 20 20
	   20 20 20 20 20
	   20 20 7C 20 20
	   20 20 20 6F 20
	   20 20 5F 5F 5F
	   5F 5F 5F 5F 5F
	   5F 5F 5F 5F 5F
	   5F 5F 5F 5F 5F
	   5F 5F 5F 5F 5F
	   5F 5F 5F 5F 20
	   20 20 0D 0A
 000008BC  20 20 20 20 20			   BYTE "         $$      |__|___|__|        /|\     O | I'm gonna break this wall |  ",0Dh,0Ah
	   20 20 20 20 24
	   24 20 20 20 20
	   20 20 7C 5F 5F
	   7C 5F 5F 5F 7C
	   5F 5F 7C 20 20
	   20 20 20 20 20
	   20 2F 7C 5C 20
	   20 20 20 20 4F
	   20 7C 20 49 27
	   6D 20 67 6F 6E
	   6E 61 20 62 72
	   65 61 6B 20 74
	   68 69 73 20 77
	   61 6C 6C 20 7C
	   20 20 0D 0A
 0000090B  20 20 20 20 20			   BYTE "        $$$$     |____|____|       / | \      | and take the coins!!!     |  ",0Dh,0Ah
	   20 20 20 24 24
	   24 24 20 20 20
	   20 20 7C 5F 5F
	   5F 5F 7C 5F 5F
	   5F 5F 7C 20 20
	   20 20 20 20 20
	   2F 20 7C 20 5C
	   20 20 20 20 20
	   20 7C 20 61 6E
	   64 20 74 61 6B
	   65 20 74 68 65
	   20 63 6F 69 6E
	   73 21 21 21 20
	   20 20 20 20 7C
	   20 20 0D 0A
 0000095A  20 20 20 20 20			   BYTE "       $$$$$$    |__|___|__|        / \       |___________________________|  ",0Dh,0Ah
	   20 20 24 24 24
	   24 24 24 20 20
	   20 20 7C 5F 5F
	   7C 5F 5F 5F 7C
	   5F 5F 7C 20 20
	   20 20 20 20 20
	   20 2F 20 5C 20
	   20 20 20 20 20
	   20 7C 5F 5F 5F
	   5F 5F 5F 5F 5F
	   5F 5F 5F 5F 5F
	   5F 5F 5F 5F 5F
	   5F 5F 5F 5F 5F
	   5F 5F 5F 5F 7C
	   20 20 0D 0A
 000009A9  20 20 20 20 20			   BYTE "      $$$$$$$$   |____|____|       /   \                                     ",0Dh,0Ah
	   20 24 24 24 24
	   24 24 24 24 20
	   20 20 7C 5F 5F
	   5F 5F 7C 5F 5F
	   5F 5F 7C 20 20
	   20 20 20 20 20
	   2F 20 20 20 5C
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 0D 0A
 000009F8  0D 0A 20 20 20			   BYTE 0Dh,0Ah,"            THE BRUTE IS TRYING TO BREAK IN!!!!!!   ",0Dh,0Ah,0Dh,0Ah,0Dh,0Ah
	   20 20 20 20 20
	   20 20 20 20 54
	   48 45 20 42 52
	   55 54 45 20 49
	   53 20 54 52 59
	   49 4E 47 20 54
	   4F 20 42 52 45
	   41 4B 20 49 4E
	   21 21 21 21 21
	   21 20 20 20 0D
	   0A 0D 0A 0D 0A
 00000A34  20 20 20 20 20			   BYTE "     - After it's done, use the cracked key in Option 2 to test it.",0Dh,0Ah,0Dh,0Ah,0
	   2D 20 41 66 74
	   65 72 20 69 74
	   27 73 20 64 6F
	   6E 65 2C 20 75
	   73 65 20 74 68
	   65 20 63 72 61
	   63 6B 65 64 20
	   6B 65 79 20 69
	   6E 20 4F 70 74
	   69 6F 6E 20 32
	   20 74 6F 20 74
	   65 73 74 20 69
	   74 2E 0D 0A 0D
	   0A 00

 00000A7C 0D 0A 0D 0A			msg3_3 BYTE 0Dh,0Ah,0Dh,0Ah
 00000A80  57 65 20 66 6F			   BYTE "We found the key: ",0Dh,0Ah,0
	   75 6E 64 20 74
	   68 65 20 6B 65
	   79 3A 20 0D 0A
	   00

					



 00000A95 65 6E 63 72 79	    fileNameE BYTE "encrypted_text.txt",0
	   70 74 65 64 5F
	   74 65 78 74 2E
	   74 78 74 00
 00000AA8 64 65 63 72 79		fileNameD BYTE "decrypted_text.txt",0
	   70 74 65 64 5F
	   74 65 78 74 2E
	   74 78 74 00
 00000ABB 30 31 5F 61 6D	    fileName0 BYTE "01_amendment_14.txt",0
	   65 6E 64 6D 65
	   6E 74 5F 31 34
	   2E 74 78 74 00
 00000ACF 30 32 5F 74 68		fileName1 BYTE "02_the_last_question.txt",0
	   65 5F 6C 61 73
	   74 5F 71 75 65
	   73 74 69 6F 6E
	   2E 74 78 74 00
 00000AE8 30 33 5F 6C 65		fileName2 BYTE "03_lebron_the_hypocrite.txt",0
	   62 72 6F 6E 5F
	   74 68 65 5F 68
	   79 70 6F 63 72
	   69 74 65 2E 74
	   78 74 00
 00000B04 62 72 75 74 65		fileNameBE BYTE "brute_etext.txt",0
	   5F 65 74 65 78
	   74 2E 74 78 74
	   00
 00000B14 62 72 75 74 65		fileNameBD BYTE "brute_otext.txt",0
	   5F 6F 74 65 78
	   74 2E 74 78 74
	   00

 = 00000BB8				textSize = 3000
 00000B24  00000BB9 [		    oText BYTE [textSize + 1] DUP (0)     ;storing the original text
	    00
	   ]
 000016DD  00000BB9 [			eText BYTE [textSize + 1] DUP (0)     ;storying encrypted text
	    00
	   ]
 00002296  00000BB9 [			BoText BYTE [textSize + 1] DUP (0)
	    00
	   ]
 00002E4F  00000BB9 [			BeText BYTE [textSize + 1] DUP (0)
	    00
	   ]
 00003A08 00000000			bytesRead DWORD ?						;how many byte read in
 00003A0C 00000000		    bytesWritten DWORD ?
 00003A10 00000000			fileHandle DWORD ?

 00003A14  0000000A [			Bkey BYTE 10 DUP(?)
	    00
	   ]
 00003A1E 00000000			BkeyLength DWORD ?
 00003A22  0000000A [		    key BYTE 10 DUP(?)          ;key stored in a char array
	    00
	   ]
 00003A2C 00000000		    keyLength DWORD ?
 00003A30 00000000		    keyType DWORD 0          	;0: empty, 1:numbers, 2:nums & lower, 3:nums & lower & upper
 00003A34 00000000		    base DWORD 0
 00003A38  0000000B [			keyInput BYTE 11 DUP(?)
	    00
	   ]
 00003A43 00000000			Bcount DWORD 0

				;macro to print a string
				printStr MACRO buffer
				    push edx
				    mov edx,OFFSET buffer
				    call WriteString
				    pop edx
				ENDM

 00000000			.code
 00000000			main PROC
 00000000  E8 00000000 E	    call Randomize
 00000005  B8 0000000F			mov eax,white+(black*16)
 0000000A  E8 00000000 E		call SetTextColor
				    ;ask user to choose which part to run, in a loop
 0000000F			Start:
 0000000F  E8 00000000 E		call Clrscr
					printStr msg0_1
 00000014  52		     1	    push edx
 00000015  BA 00000000 R     1	    mov edx,OFFSET msg0_1
 0000001A  E8 00000000 E     1	    call WriteString
 0000001F  5A		     1	    pop edx
 00000020  B8 00000000			mov eax,0
 00000025  E8 00000000 E		call ReadInt
 0000002A  83 F8 01			cmp eax,1
 0000002D  74 14			je O1
 0000002F  83 F8 02			cmp eax,2
 00000032  74 16			je O2
 00000034  83 F8 03		    cmp eax,3
 00000037  74 18		    je O3
 00000039  83 F8 08			cmp eax,8
 0000003C  74 1A			je O8
 0000003E  83 F8 00			cmp eax,0
 00000041  74 35			je Finish
 00000043			O1:
 00000043  E8 00000041			call option1
 00000048  EB C5			jmp Start
 0000004A			O2:
 0000004A  E8 000001CD			call option2
 0000004F  EB BE			jmp Start
 00000051			O3:
 00000051  E8 000002BC		    call option3

					
 00000056  EB B7			jmp Start
 00000058			O8:
 00000058  E8 00000000 E		call Clrscr
 0000005D  B8 000000F0			mov eax,black+(white*16)
 00000062  E8 00000000 E		call SetTextColor
 00000067  B8 0000000F			mov eax,white+(black*16)
 0000006C  E8 00000000 E		call SetTextColor
 00000071  E8 00000000 E		call WaitMsg
 00000076  EB 97		    jmp Start
 00000078			Finish:
 00000078  E8 00000A3F			call wipeText
 0000007D  E8 00000A6D			call wipeKey
					invoke ExitProcess,0
 00000082  6A 00	   *	    push   +000000000h
 00000084  E8 00000000 E   *	    call   ExitProcess
 00000089			main ENDP

				;----------------------------------------------------------
 00000089			option1 PROC
				;	Encryption: Pick a text, pick a key, encrypt it.
				;	Input:		None
				;	Output:		None
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
 00000089			O1Start:
 00000089  E8 00000000 E		call Clrscr
 0000008E  B8 000000F4			mov eax,red+(white*16)
 00000093  E8 00000000 E		call SetTextColor
					printStr msg1_6
 00000098  52		     1	    push edx
 00000099  BA 000003DA R     1	    mov edx,OFFSET msg1_6
 0000009E  E8 00000000 E     1	    call WriteString
 000000A3  5A		     1	    pop edx
 000000A4  B8 0000000F			mov eax,white+(black*16)
 000000A9  E8 00000000 E		call SetTextColor
					printStr msg1_11
 000000AE  52		     1	    push edx
 000000AF  BA 0000040F R     1	    mov edx,OFFSET msg1_11
 000000B4  E8 00000000 E     1	    call WriteString
 000000B9  5A		     1	    pop edx
 000000BA  B8 00000000			mov eax,0
 000000BF  E8 00000000 E		call ReadInt
 000000C4  83 F8 01			cmp eax,1
 000000C7  74 17			je O1_1
 000000C9  83 F8 02			cmp eax,2
 000000CC  74 7C			je O1_2
 000000CE  83 F8 03		    cmp eax,3
 000000D1  0F 84 000000DA	    je O1_3
 000000D7  83 F8 00			cmp eax,0
 000000DA  0F 84 0000013B		je O1Return
 000000E0			O1_1:
 000000E0  E8 000009D7			call wipeText
 000000E5  68 00000B24 R		push OFFSET oText
 000000EA  68 00000ABB R	    push OFFSET fileName0
 000000EF  E8 00000934		    call readText
				    printStr msg1_7
 000000F4  52		     1	    push edx
 000000F5  BA 000004BD R     1	    mov edx,OFFSET msg1_7
 000000FA  E8 00000000 E     1	    call WriteString
 000000FF  5A		     1	    pop edx
 00000100  68 00000B24 R	    push OFFSET oText
 00000105  E8 0000097A		    call printText
 0000010A  E8 00000273		    call keyOption
 0000010F  E8 000004C5		    call encryptText
				    printStr msg1_8
 00000114  52		     1	    push edx
 00000115  BA 000004DC R     1	    mov edx,OFFSET msg1_8
 0000011A  E8 00000000 E     1	    call WriteString
 0000011F  5A		     1	    pop edx
 00000120  68 000016DD R	    push OFFSET eText
 00000125  E8 0000095A		    call printText
 0000012A  68 000016DD R		push OFFSET eText
 0000012F  68 00000A95 R		push OFFSET fileNameE
 00000134  E8 0000091F		    call writeText
				    printStr msg1_9
 00000139  52		     1	    push edx
 0000013A  BA 000004FC R     1	    mov edx,OFFSET msg1_9
 0000013F  E8 00000000 E     1	    call WriteString
 00000144  5A		     1	    pop edx
 00000145  E9 000000CC			jmp O1Finish
 0000014A			O1_2:
 0000014A  E8 0000096D			call wipeText
 0000014F  68 00000B24 R		push OFFSET oText
 00000154  68 00000ACF R	    push OFFSET fileName1
 00000159  E8 000008CA		    call readText
				    printStr msg1_7
 0000015E  52		     1	    push edx
 0000015F  BA 000004BD R     1	    mov edx,OFFSET msg1_7
 00000164  E8 00000000 E     1	    call WriteString
 00000169  5A		     1	    pop edx
 0000016A  68 00000B24 R	    push OFFSET  oText
 0000016F  E8 00000910		    call printText
 00000174  E8 00000209		    call keyOption
 00000179  E8 0000045B		    call encryptText
				    printStr msg1_8
 0000017E  52		     1	    push edx
 0000017F  BA 000004DC R     1	    mov edx,OFFSET msg1_8
 00000184  E8 00000000 E     1	    call WriteString
 00000189  5A		     1	    pop edx
 0000018A  68 000016DD R	    push OFFSET eText
 0000018F  E8 000008F0		    call printText
 00000194  68 000016DD R		push OFFSET eText
 00000199  68 00000A95 R		push OFFSET fileNameE
 0000019E  E8 000008B5		    call writeText
				    printStr msg1_9
 000001A3  52		     1	    push edx
 000001A4  BA 000004FC R     1	    mov edx,OFFSET msg1_9
 000001A9  E8 00000000 E     1	    call WriteString
 000001AE  5A		     1	    pop edx
 000001AF  EB 65		    jmp O1Finish
 000001B1			O1_3:
 000001B1  E8 00000906			call wipeText
 000001B6  68 00000B24 R		push OFFSET oText
 000001BB  68 00000AE8 R	    push OFFSET fileName2
 000001C0  E8 00000863		    call readText
				    printStr msg1_7
 000001C5  52		     1	    push edx
 000001C6  BA 000004BD R     1	    mov edx,OFFSET msg1_7
 000001CB  E8 00000000 E     1	    call WriteString
 000001D0  5A		     1	    pop edx
 000001D1  68 00000B24 R	    push OFFSET  oText
 000001D6  E8 000008A9		    call printText
 000001DB  E8 000001A2		    call keyOption
 000001E0  E8 000003F4		    call encryptText
				    printStr msg1_8
 000001E5  52		     1	    push edx
 000001E6  BA 000004DC R     1	    mov edx,OFFSET msg1_8
 000001EB  E8 00000000 E     1	    call WriteString
 000001F0  5A		     1	    pop edx
 000001F1  68 000016DD R	    push OFFSET eText
 000001F6  E8 00000889		    call printText
 000001FB  68 000016DD R		push OFFSET eText
 00000200  68 00000A95 R		push OFFSET fileNameE
 00000205  E8 0000084E		    call writeText
				    printStr msg1_9
 0000020A  52		     1	    push edx
 0000020B  BA 000004FC R     1	    mov edx,OFFSET msg1_9
 00000210  E8 00000000 E     1	    call WriteString
 00000215  5A		     1	    pop edx
 00000216			O1Finish:
 00000216  E8 00000000 E		call WaitMsg
 0000021B			O1Return:
 0000021B  C3			    ret
 0000021C			option1 ENDP

				;----------------------------------------------------------
 0000021C			option2 PROC
				;	Encryption: load encrypted_text.txt
				;	Input:		None
				;	Output:		None
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
 0000021C			O2Start:
 0000021C  E8 00000000 E		call Clrscr
 00000221  B8 000000F4			mov eax,red+(white*16)
 00000226  E8 00000000 E		call SetTextColor
					printStr msg2_0
 0000022B  52		     1	    push edx
 0000022C  BA 00000587 R     1	    mov edx,OFFSET msg2_0
 00000231  E8 00000000 E     1	    call WriteString
 00000236  5A		     1	    pop edx
 00000237  B8 0000000F			mov eax,white+(black*16)
 0000023C  E8 00000000 E		call SetTextColor
					printStr msg2_6
 00000241  52		     1	    push edx
 00000242  BA 000005BC R     1	    mov edx,OFFSET msg2_6
 00000247  E8 00000000 E     1	    call WriteString
 0000024C  5A		     1	    pop edx
 0000024D  8D 15 00000A95 R		lea edx,fileNameE
 00000253  E8 00000000 E		call OpenInputFIle
 00000258  A3 00003A10 R		mov fileHandle,eax
 0000025D  BA 000016DD R		mov edx,OFFSET eText
 00000262  B9 00000BB8			mov ecx,textSize
 00000267  E8 00000000 E		call ReadFromFile
 0000026C  A3 00003A08 R		mov bytesRead,eax
 00000271  A1 00003A10 R		mov eax,fileHandle
 00000276  E8 00000000 E		call CloseFile

				    printStr msg1_8
 0000027B  52		     1	    push edx
 0000027C  BA 000004DC R     1	    mov edx,OFFSET msg1_8
 00000281  E8 00000000 E     1	    call WriteString
 00000286  5A		     1	    pop edx
 00000287  68 000016DD R	    push OFFSET eText
 0000028C  E8 000007F3		    call printText

					printStr msg2_5
 00000291  52		     1	    push edx
 00000292  BA 000005DC R     1	    mov edx,OFFSET msg2_5
 00000297  E8 00000000 E     1	    call WriteString
 0000029C  5A		     1	    pop edx
 0000029D  B8 00000000			mov eax,0
 000002A2  E8 00000000 E		call ReadInt
 000002A7  83 F8 01			cmp eax,1
 000002AA  74 0A			je O2_1
 000002AC  83 F8 02			cmp eax,2
 000002AF  74 54			je O2_2
 000002B1  83 F8 00			cmp eax,0
 000002B4  74 5B			je O2Return

 000002B6			O2_1:
 000002B6  83 3D 00003A2C R		cmp keyLength,0
	   00
 000002BD  77 0E			ja goOn
					printStr err1_1
 000002BF  52		     1	    push edx
 000002C0  BA 00000561 R     1	    mov edx,OFFSET err1_1
 000002C5  E8 00000000 E     1	    call WriteString
 000002CA  5A		     1	    pop edx
 000002CB  EB 3F			jmp O2Finish
 000002CD			goOn:
 000002CD  E8 000004AE			call decryptText
					printStr msg2_1
 000002D2  52		     1	    push edx
 000002D3  BA 00000663 R     1	    mov edx,OFFSET msg2_1
 000002D8  E8 00000000 E     1	    call WriteString
 000002DD  5A		     1	    pop edx
 000002DE  68 00000B24 R		push OFFSET oText
 000002E3  E8 0000079C			call printText
 000002E8  68 00000B24 R		push OFFSET oText
 000002ED  68 00000AA8 R		push OFFSET fileNameD
 000002F2  E8 00000761			call writeText
					printStr msg2_2
 000002F7  52		     1	    push edx
 000002F8  BA 00000683 R     1	    mov edx,OFFSET msg2_2
 000002FD  E8 00000000 E     1	    call WriteString
 00000302  5A		     1	    pop edx
 00000303  EB 07			jmp O2Finish
 00000305			O2_2:
 00000305  E8 0000009A			call enterKey
 0000030A  EB AA			jmp O2_1
 0000030C			O2Finish:
 0000030C  E8 00000000 E		call WaitMsg
 00000311			O2Return:
 00000311  C3				ret
 00000312			option2 ENDP

				;----------------------------------------------------------
 00000312			option3 PROC
				;	Encryption: load encrypted_text.txt
				;	Input:		None
				;	Output:		None
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
 00000312			O3Start:
 00000312  E8 00000000 E		call Clrscr
 00000317  B8 000000F4			mov eax,red+(white*16)
 0000031C  E8 00000000 E		call SetTextColor
					printStr msg3_0
 00000321  52		     1	    push edx
 00000322  BA 0000072C R     1	    mov edx,OFFSET msg3_0
 00000327  E8 00000000 E     1	    call WriteString
 0000032C  5A		     1	    pop edx
 0000032D  B8 0000000F			mov eax,white+(black*16)
 00000332  E8 00000000 E		call SetTextColor

 00000337  68 00002296 R		push OFFSET BoText
 0000033C  68 00000ABB R		push OFFSET fileName0
 00000341  E8 000006E2			call readText

 00000346  68 000016DD R		push OFFSET eText
 0000034B  68 00000A95 R		push OFFSET fileNameE
 00000350  E8 000006D3			call readText

					printStr msg3_1
 00000355  52		     1	    push edx
 00000356  BA 0000075E R     1	    mov edx,OFFSET msg3_1
 0000035B  E8 00000000 E     1	    call WriteString
 00000360  5A		     1	    pop edx
					printStr msg3_2
 00000361  52		     1	    push edx
 00000362  BA 000007CF R     1	    mov edx,OFFSET msg3_2
 00000367  E8 00000000 E     1	    call WriteString
 0000036C  5A		     1	    pop edx

 0000036D  E8 00000556			call bruteForce
 00000372  E8 00000000 E		call Crlf
 00000377  E8 00000000 E		call Crlf


 0000037C			O3Finish:
 0000037C  E8 00000000 E		call WaitMsg
 00000381			O3Return:
 00000381  C3				ret
 00000382			option3 ENDP

				;----------------------------------------------------------
 00000382			keyOption PROC
				;	Ask user if he/she want to enter a key, or generate a key
				;	Input:		None
				;	Output:		None
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
					printStr msg1_10
 00000382  52		     1	    push edx
 00000383  BA 00000530 R     1	    mov edx,OFFSET msg1_10
 00000388  E8 00000000 E     1	    call WriteString
 0000038D  5A		     1	    pop edx
 0000038E  E8 00000000 E	    call ReadChar
 00000393  3C 79		    cmp al,121
 00000395  74 07			je userEnterKey
 00000397  E8 00000075			call pickKey
 0000039C  EB 05			jmp keyDone
 0000039E			userEnterKey:
 0000039E  E8 00000001			call enterKey
 000003A3			keyDone:
 000003A3  C3				ret
 000003A4			keyOption ENDP

				;----------------------------------------------------------
 000003A4			enterKey PROC
				;	Ask user to enter a key
				;	Input:		key
				;				keyInput
				;				keyLength
				;	Output:		key
				;				keyLength
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
 000003A4			Start:
					printStr msg2_3
 000003A4  52		     1	    push edx
 000003A5  BA 000006B7 R     1	    mov edx,OFFSET msg2_3
 000003AA  E8 00000000 E     1	    call WriteString
 000003AF  5A		     1	    pop edx
 000003B0  8D 15 00003A38 R		lea edx,keyInput
 000003B6  B9 0000000B			mov ecx,11
 000003BB  E8 00000000 E		call ReadString
 000003C0  83 F8 04			cmp eax,4
 000003C3  77 0E			ja keyOkay
					printStr err2_0
 000003C5  52		     1	    push edx
 000003C6  BA 00000714 R     1	    mov edx,OFFSET err2_0
 000003CB  E8 00000000 E     1	    call WriteString
 000003D0  5A		     1	    pop edx
 000003D1  EB D1			jmp Start
 000003D3			keyOkay:
 000003D3  A3 00003A2C R		mov keyLength,eax
 000003D8  B8 0000000A			mov eax,10
 000003DD  2B 05 00003A2C R		sub eax,keyLength
 000003E3  8D 35 00003A22 R		lea esi,key
 000003E9  03 F0			add esi,eax
 000003EB  8D 1D 00003A38 R		lea ebx,keyInput
 000003F1  8B 0D 00003A2C R		mov ecx,keyLength
 000003F7			copyKey:
 000003F7  8A 03			mov al,BYTE PTR [ebx]
 000003F9  88 06			mov BYTE PTR [esi],al
 000003FB  43				inc ebx
 000003FC  46				inc esi
 000003FD  E2 F8			loop copyKey
					printStr msg2_4
 000003FF  52		     1	    push edx
 00000400  BA 00000706 R     1	    mov edx,OFFSET msg2_4
 00000405  E8 00000000 E     1	    call WriteString
 0000040A  5A		     1	    pop edx
 0000040B  E8 000001A4			call printKey
 00000410  C3				ret
 00000411			enterKey ENDP

				;----------------------------------------------------------
 00000411			pickKey PROC
				;	
				;	Input:		None
				;	Output:		None
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
 00000411			Start:
				    printStr msg1_0
 00000411  52		     1	    push edx
 00000412  BA 000002E5 R     1	    mov edx,OFFSET msg1_0
 00000417  E8 00000000 E     1	    call WriteString
 0000041C  5A		     1	    pop edx
 0000041D  E8 00000000 E	    call ReadDec
 00000422  83 F8 05		    cmp eax,5
 00000425  72 05		    jb InvalidLength
 00000427  83 F8 0A		    cmp eax,10
 0000042A  76 0E		    jbe Next
 0000042C			InvalidLength:
				    printStr err1_0
 0000042C  52		     1	    push edx
 0000042D  BA 0000054D R     1	    mov edx,OFFSET err1_0
 00000432  E8 00000000 E     1	    call WriteString
 00000437  5A		     1	    pop edx
 00000438  EB D7		    jmp Start
 0000043A			Next:
 0000043A  A3 00003A2C R		mov keyLength,eax
 0000043F			L:
 0000043F  C7 05 00003A30 R		mov keyType,0			;reset key info
	   00000000
 00000449  C7 05 00003A34 R	    mov base,0
	   00000000
				    printStr msg1_1
 00000453  52		     1	    push edx
 00000454  BA 00000319 R     1	    mov edx,OFFSET msg1_1
 00000459  E8 00000000 E     1	    call WriteString
 0000045E  5A		     1	    pop edx
 0000045F  E8 00000000 E	    call ReadChar
 00000464  3C 79		    cmp al,121
 00000466  75 0E		    jne N1
 00000468  83 35 00003A30 R	    xor keyType,1           ;key has 0-9
	   01
 0000046F  83 05 00003A34 R	    add base,10
	   0A
 00000476			N1:
				    printStr msg1_2
 00000476  52		     1	    push edx
 00000477  BA 00000347 R     1	    mov edx,OFFSET msg1_2
 0000047C  E8 00000000 E     1	    call WriteString
 00000481  5A		     1	    pop edx
 00000482  E8 00000000 E	    call ReadChar
 00000487  3C 79		    cmp al,121
 00000489  75 0E		    jne N2
 0000048B  83 35 00003A30 R	    xor keyType,2           ;key has a-z
	   02
 00000492  83 05 00003A34 R	    add base,26
	   1A
 00000499			N2:
				    printStr msg1_3
 00000499  52		     1	    push edx
 0000049A  BA 0000037F R     1	    mov edx,OFFSET msg1_3
 0000049F  E8 00000000 E     1	    call WriteString
 000004A4  5A		     1	    pop edx
 000004A5  E8 00000000 E	    call ReadChar
 000004AA  3C 79		    cmp al,121
 000004AC  75 0E		    jne N3
 000004AE  83 35 00003A30 R	    xor keyType,4           ;key has A-Z
	   04
 000004B5  83 05 00003A34 R	    add base,26
	   1A
 000004BC			N3:
 000004BC  83 3D 00003A30 R	    cmp keyType,0
	   00
 000004C3  74 30		    je emptyKey
 000004C5			N4:
 000004C5  E8 0000003C		    call generateKey
				    printStr msg1_4
 000004CA  52		     1	    push edx
 000004CB  BA 000003B7 R     1	    mov edx,OFFSET msg1_4
 000004D0  E8 00000000 E     1	    call WriteString
 000004D5  5A		     1	    pop edx
 000004D6  E8 000000D9		    call printKey
				    printStr msg1_5
 000004DB  52		     1	    push edx
 000004DC  BA 000003CB R     1	    mov edx,OFFSET msg1_5
 000004E1  E8 00000000 E     1	    call WriteString
 000004E6  5A		     1	    pop edx
 000004E7  E8 00000000 E	    call ReadChar
 000004EC  3C 79		    cmp al,121
 000004EE  74 04		    je Done
 000004F0  3C 6E		    cmp al,110
 000004F2  74 D1		    je N4
 000004F4			Done:
 000004F4  C3			    ret
 000004F5			emptyKey:
				    printStr err1_1
 000004F5  52		     1	    push edx
 000004F6  BA 00000561 R     1	    mov edx,OFFSET err1_1
 000004FB  E8 00000000 E     1	    call WriteString
 00000500  5A		     1	    pop edx
 00000501  E9 FFFFFF39		    jmp L
 00000506			pickKey ENDP

				;----------------------------------------------------------
 00000506			generateKey PROC
				;   Randomly generate a key with length 5-10,
				;   contains 0-9 & a-z & A-Z
				;   (10 + 26  + 26 = 62 unique characters)
				;
				;   Base on keyType, use different loops to generate random key
				;	
				;	Input:		key
				;               keyLength
				;               keyType
				;               base
				;	Output:		key
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
 = DWORD PTR [ebp-4]		    uniqueChar EQU DWORD PTR [ebp-4]
 00000506  55			    push ebp
 00000507  8B EC		    mov ebp,esp
 00000509  83 EC 04		    sub esp,4           ;1 local DWORD

				;   dec  bin     condition
				;    0   0000    empty
				;    1   0001    numbers
				;    2   0010    lowercase
				;    4   0100    uppercase
				;eg: if user picks nums: xor keyType,1
				;    then user picks uppercase: xor keyType,4

 0000050C  8B 0D 00003A2C R	    mov ecx,keyLength
 00000512  BE 00003A22 R	    mov esi,OFFSET key
 00000517  83 C6 09		    add esi,9

				;decide which loop to use
 0000051A  83 3D 00003A30 R	    cmp keyType,7
	   07
 00000521  74 36		    je L1
 00000523  83 3D 00003A30 R	    cmp keyType,1
	   01
 0000052A  74 2D		    je L1
 0000052C  83 3D 00003A30 R	    cmp keyType,5
	   05
 00000533  74 24		    je L1
 00000535  83 3D 00003A30 R	    cmp keyType,4
	   04
 0000053C  74 3E		    je L2
 0000053E  83 3D 00003A30 R	    cmp keyType,6
	   06
 00000545  74 35		    je L2
 00000547  83 3D 00003A30 R	    cmp keyType,2
	   02
 0000054E  74 47		    je L3
 00000550  83 3D 00003A30 R	    cmp keyType,3
	   03
 00000557  74 3E		    je L3

				;loop for all chars, 0-9 only, or 0-9 & uppercase (b = 62)
				;0-9:   0-9   +48
				;10-35: A-Z   +55
				;36-61: a-z   +61
 00000559			L1:
 00000559  A1 00003A34 R	    mov eax,base
 0000055E  E8 00000000 E	    call RandomRange
 00000563  3C 09		    cmp al,9
 00000565  77 04		    ja  alphabets 
 00000567  04 30		    add al,48
 00000569  EB 0A		    jmp Next1

 0000056B			alphabets:
 0000056B  3C 23		    cmp al,35
 0000056D  77 04		    ja lowercase1
 0000056F  04 37		    add al,55
 00000571  EB 02		    jmp Next1

 00000573			lowercase1:
 00000573  04 3D		    add al,61

 00000575			Next1:
 00000575  88 06		    mov BYTE PTR [esi],al
 00000577  4E			    dec esi
 00000578  E2 DF		    loop L1

 0000057A  EB 34		    jmp Finish

				;loop for uppercase only, lower & upper (b = 52)
				;0-25: A-Z    +65
				;26-51: a-z   +71
 0000057C			L2:
 0000057C  A1 00003A34 R	    mov eax,base
 00000581  E8 00000000 E	    call RandomRange
 00000586  3C 19		    cmp al,25
 00000588  77 04		    ja  lowercase2 
 0000058A  04 41		    add al,65
 0000058C  EB 02		    jmp Next2

 0000058E			lowercase2:
 0000058E  04 47		    add al,71

 00000590			Next2:
 00000590  88 06		    mov BYTE PTR [esi],al
 00000592  4E			    dec esi
 00000593  E2 E7		    loop L2

 00000595  EB 19		    jmp Finish

				;loop for lower only, lower & 0-9  (b = 36)
				;0-25:   a-z   +97
				;25-35:  0-9   +23
 00000597			L3:
 00000597  A1 00003A34 R	    mov eax,base
 0000059C  E8 00000000 E	    call RandomRange
 000005A1  3C 19		    cmp al,25
 000005A3  77 04		    ja  numbers 
 000005A5  04 61		    add al,97
 000005A7  EB 02		    jmp Next3

 000005A9			numbers:
 000005A9  04 17		    add al,23

 000005AB			Next3:
 000005AB  88 06		    mov BYTE PTR [esi],al
 000005AD  4E			    dec esi
 000005AE  E2 E7		    loop L3

 000005B0			Finish:
 000005B0  8B E5		    mov esp,ebp
 000005B2  5D			    pop ebp
 000005B3  C3			    ret
 000005B4			generateKey ENDP

				;----------------------------------------------------------
 000005B4			printKey PROC
				;	
				;	Input:		None
				;	Output:		None
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
 000005B4  BB 0000000A		    mov ebx,10
 000005B9  2B 1D 00003A2C R	    sub ebx,keyLength
 000005BF  BE 00003A22 R	    mov esi,OFFSET key
 000005C4  03 F3		    add esi,ebx
 000005C6  8B 0D 00003A2C R	    mov ecx,keyLength
 000005CC			printLoop:
 000005CC  8A 06		    mov al,BYTE PTR [esi]
 000005CE  E8 00000000 E	    call WriteChar
 000005D3  83 C6 01		    add esi,1
 000005D6  E2 F4		    loop printLoop
 000005D8  C3			    ret
 000005D9			printKey ENDP

				;----------------------------------------------------------
 000005D9			encryptText PROC
				;	Use Columnar Transposition Cipher algorithm to encrypt
				;	
				;	Input:		oText
				;               eText
				;               key
				;               keyLength
				;               bytesRead
				;	Output:		eText
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
 = DWORD PTR [ebp-4]		    oTextEnd EQU DWORD PTR [ebp-4]
 = DWORD PTR [ebp-8]		    rowCount EQU DWORD PTR [ebp-8]
 = DWORD PTR [ebp-12]		    padCount EQU DWORD PTR [ebp-12]
 = DWORD PTR [ebp-16]		    keyPTR EQU DWORD PTR [ebp-16]       ;address to start of key
 = DWORD PTR [ebp-20]		    col0 EQU DWORD PTR [ebp-20]        ;address to col0
 = DWORD PTR [ebp-24]		    col1 EQU DWORD PTR [ebp-24] 
 = DWORD PTR [ebp-28]		    col2 EQU DWORD PTR [ebp-28] 
 = DWORD PTR [ebp-32]		    col3 EQU DWORD PTR [ebp-32] 
 = DWORD PTR [ebp-36]		    col4 EQU DWORD PTR [ebp-36] 
 = DWORD PTR [ebp-40]		    col5 EQU DWORD PTR [ebp-40] 
 = DWORD PTR [ebp-44]		    col6 EQU DWORD PTR [ebp-44] 
 = DWORD PTR [ebp-48]		    col7 EQU DWORD PTR [ebp-48] 
 = DWORD PTR [ebp-52]		    col8 EQU DWORD PTR [ebp-52] 
 = DWORD PTR [ebp-56]		    col9 EQU DWORD PTR [ebp-56]
 = DWORD PTR [ebp-60]		    cOrder0 EQU DWORD PTR [ebp-60]
 = DWORD PTR [ebp-100]		    count EQU DWORD PTR [ebp-100]
 = BYTE PTR [ebp-104]		    lower EQU BYTE PTR [ebp-104]
 = BYTE PTR [ebp-108]		    upper EQU BYTE PTR [ebp-108]
 = DWORD PTR [ebp-112]		    index EQU DWORD PTR [ebp-112]
 = DWORD PTR [ebp-116]		    temp1 EQU DWORD PTR [ebp-116]

 = 0000005F			    pad = '_'
 000005D9  55			    push ebp
 000005DA  8B EC		    mov ebp,esp
 000005DC  83 EC 74		    sub esp,116           ;29 local DWORDs

				;wipe local variables
 000005DF  B9 0000001D			mov ecx,29
 000005E4  8B F5			mov esi,ebp
 000005E6			wipe:
 000005E6  C7 06 00000000		mov DWORD PTR [esi],0
 000005EC  83 EE 04			sub esi,4
 000005EF  E2 F5			loop wipe

				;get oTextEnd
				;    mov eax,SIZEOF oText
				;    mov esi,OFFSET oText
				;    mov oTextEnd,esi
				;    add oTextEnd,eax
				;    dec oTextEnd                ;address of last char in oText

				;calculate rowCount & padCount at the end of the oText
 000005F1  BA 00000000			mov edx,0
 000005F6  A1 00003A08 R		mov eax,bytesRead  
 000005FB  8B 0D 00003A2C R		mov ecx,keyLength
 00000601  F7 F1			div ecx
 00000603  83 FA 00			cmp edx,0
 00000606  77 0C			ja Padding
 00000608  C7 45 F4			mov padCount,0
	   00000000
 0000060F  89 45 F8			mov rowCount,eax
 00000612  EB 09			jmp NoPadding

 00000614			Padding:
 00000614  2B CA			sub ecx,edx
 00000616  89 4D F4			mov padCount,ecx
 00000619  40				inc eax
 0000061A  89 45 F8			mov rowCount,eax

 0000061D			NoPadding:

				;get keyPTR
 0000061D  BE 00003A22 R		mov esi,OFFSET key
 00000622  B8 0000000A			mov eax,10
 00000627  2B 05 00003A2C R		sub eax,keyLength
 0000062D  03 F0			add esi,eax
 0000062F  89 75 F0			mov keyPTR,esi

					; mov eax,bytesRead
					; call WriteDec
					; call Crlf
					; mov eax,rowCount
					; call WriteDec
					; call Crlf
					; mov eax,padCount
					; call WriteDec
					; call Crlf

				comment !
				method 1:
				1. determine the starting address of each column
				2. determine the index modifier (order) of each column
				        eg: HACK - > 3,1,2,4
				3. go through the oText once:
				        a)each byte has its own index modifier
				        b)use the index modifier to determine which column to write
				        c)write the byte to column and increase column offset by 1
				!

				;break up the encrypted eText into columns
				;store address for each column in col0 - col9
 00000632  8B 0D 00003A2C R		mov ecx,keyLength
 00000638  B8 000016DD R		mov eax,OFFSET eText
 0000063D  8B F5			mov esi,ebp				;col0
 0000063F  83 EE 14			sub esi,20
 00000642			colLoop:
 00000642  89 06			mov DWORD PTR [esi],eax
 00000644  03 45 F8			add eax,rowCount
 00000647  83 EE 04			sub esi,4
 0000064A  E2 F6			loop colLoop

				;go through the index modifiers and sort them
				;loop through the key
				;pick the lowest value each iteartion,assign order in column orders

				;for each char:
				;	1. if column order > 0, skip to next char
				;	2. if char < lower, set char to upper

				;macro to get column order address based on index
				goCol MACRO
					push eax
					push edx
					mov esi,ebp			;cOrder0
					sub esi,60
					mov eax,index
					mov edx,4
					mul edx
					sub esi,eax
					pop edx
					pop eax
				ENDM

 0000064C  C6 45 98 7B			mov lower,123
 00000650  8B 0D 00003A2C R		mov ecx,keyLength
 00000656  C7 45 9C			mov count,1
	   00000001
 0000065D			sortL1:
 0000065D  51				push ecx
 0000065E  C6 45 98 7B			mov lower,123
 00000662  8B 0D 00003A2C R		mov ecx,keyLength
 00000668  8B 7D F0			mov edi,keyPTR					;keyPTR
 0000066B  C7 45 90			mov index,0					;current key position
	   00000000
 00000672				sortL2:
						;check if column order is empty
						goCol                          ;go to current column order
 00000672  50		     1		push eax
 00000673  52		     1		push edx
 00000674  8B F5	     1		mov esi,ebp			;cOrder0
 00000676  83 EE 3C	     1		sub esi,60
 00000679  8B 45 90	     1		mov eax,index
 0000067C  BA 00000004	     1		mov edx,4
 00000681  F7 E2	     1		mul edx
 00000683  2B F0	     1		sub esi,eax
 00000685  5A		     1		pop edx
 00000686  58		     1		pop eax
 00000687  83 3E 00				cmp DWORD PTR [esi],0
 0000068A  77 26				ja nextChar                     ;this char already has an order

 0000068C  8A 45 98				mov al,lower
 0000068F  38 07				cmp BYTE PTR [edi],al
 00000691  72 02				jb foundLower
 00000693  EB 1D				jmp nextChar

 00000695				foundLower:
 00000695  8A 07				mov al,BYTE PTR [edi]
 00000697  88 45 98				mov lower,al                    ;store the new lowest ascii
						goCol                           ;go to current column order
 0000069A  50		     1		push eax
 0000069B  52		     1		push edx
 0000069C  8B F5	     1		mov esi,ebp			;cOrder0
 0000069E  83 EE 3C	     1		sub esi,60
 000006A1  8B 45 90	     1		mov eax,index
 000006A4  BA 00000004	     1		mov edx,4
 000006A9  F7 E2	     1		mul edx
 000006AB  2B F0	     1		sub esi,eax
 000006AD  5A		     1		pop edx
 000006AE  58		     1		pop eax
 000006AF  89 75 8C				mov temp1,esi                   ;remember the current column

 000006B2				nextChar:
 000006B2  FF 45 90				inc index
 000006B5  47					inc edi

 000006B6				continue:
 000006B6  E2 BA				loop sortL2

					;mov count to the column
 000006B8  8B 45 9C			mov eax,count
 000006BB  8B 75 8C			mov esi,temp1
 000006BE  89 06			mov DWORD PTR [esi],eax

 000006C0  59				pop ecx
 000006C1  FF 45 9C			inc count
 000006C4  E2 97			loop sortL1

				;comment !
				;Testing column order sorting
 000006C6  E8 00000000 E		call Crlf
 000006CB  E8 00000000 E		call Crlf
 000006D0  8B 0D 00003A2C R		mov ecx,keyLength
 000006D6  8B F5			mov esi,ebp			;cOrder0
 000006D8  83 EE 3C			sub esi,60
 000006DB			testL1:
 000006DB  8B 06			mov eax,DWORD PTR [esi]
 000006DD  E8 00000000 E		call WriteDec
 000006E2  B0 20			mov al,' '
 000006E4  E8 00000000 E		call WriteChar
 000006E9  83 EE 04			sub esi,4
 000006EC  E2 ED			loop testL1
 000006EE  E8 00000000 E		call Crlf
 000006F3  E8 00000000 E		call Crlf
				;!

				comment !

				Example:
					key =    H A C K K A
					order =  4 1 3 5 6 2
					keyLength = 6

					oText:
						"I didn't buy anything this Black Friday because I don't have any money. "
						 413562413562413562413562413562413562413562413562413562413562413562413562
				!

 000006F8  BE 00000B24 R	    mov esi,OFFSET oText
 000006FD  8B FD			mov edi,ebp
 000006FF  83 EF 3C			sub edi,60			;cOrder0
 00000702  B9 00000001			mov ecx,1
 00000707			readoText:
 00000707  8B D5			mov edx,ebp                     ;col0
 00000709  83 EA 14			sub edx,20
 0000070C  8A 1E			mov bl,BYTE PTR [esi]
 0000070E  80 FB 00			cmp bl,0
 00000711  74 30			je endOfoText

 00000713  3B 0D 00003A2C R		cmp ecx,keyLength
 00000719  77 02			ja Reorder
 0000071B  EB 0A			jmp writeeText

 0000071D			Reorder:
 0000071D  B9 00000001			mov ecx,1
 00000722  8B FD			mov edi,ebp
 00000724  83 EF 3C			sub edi,60			;cOrder0

 00000727			writeeText:
 00000727  8B 07			mov eax,DWORD PTR [edi]         ;get order
 00000729  48				dec eax                         ;change start of order to 0
 0000072A  52				push edx
 0000072B  BA 00000004			mov edx,4
 00000730  F7 E2			mul edx                         ;order * 4 = correct column
 00000732  5A				pop edx

 00000733  2B D0			sub edx,eax                     ;go to the correct column
 00000735  8B 02			mov eax,DWORD PTR [edx]         ;address to the position in eText
 00000737  88 18			mov BYTE PTR [eax],bl
 00000739  40				inc eax                         ;point to the next empty location in eText
 0000073A  89 02			mov DWORD PTR [edx],eax         ;update column address

 0000073C  83 EF 04			sub edi,4                       ;next order number
 0000073F  46				inc esi                         ;next char in oText
 00000740  41				inc ecx                         ;keyLength counter

 00000741  EB C4			jmp readoText

 00000743			endOfoText:

				comment !
				;add padding to eText
					cmp padCount,0
					je encryptionDone

				    mov ecx,padCount
				    lea ebx,col0
				    mov eax,keyLength
					dec eax
				    mov edx,4
				    mul edx
				    sub ebx,eax						;go to the last column pointer
				addPaddingToEText:
				    mov esi,DWORD PTR [ebx]			;go to the last column in eText
				    mov BYTE PTR [esi],pad
				    add ebx,4						;move to previous column pointer
				    loop addPaddingToEText

				;add padding to end of oText
					mov esi,OFFSET oText
					add esi,bytesRead
					mov ecx,padCount
				addPaddingToOText:
					mov BYTE PTR [esi],pad
					inc esi
					loop addPaddingToOText

				;add padCount to bytesRead
					mov eax,bytesRead
					add eax,padCount
					mov bytesRead,eax
				!

				;add padding to eText
 00000743  83 7D F4 00			cmp padCount,0
 00000747  74 33			je encryptionDone
 00000749  8B 0D 00003A08 R		mov ecx,bytesRead
 0000074F  03 4D F4			add ecx,padCount
 00000752  89 0D 00003A08 R		mov bytesRead,ecx
 00000758  BE 00000B24 R		mov esi,OFFSET oText
 0000075D  BB 000016DD R		mov ebx,OFFSET eText
 00000762			addPads:
 00000762  80 3E 00			cmp BYTE PTR [esi],0
 00000765  74 02			je oPad
 00000767  EB 03			jmp nextPart
 00000769				oPad:
 00000769  C6 06 5F				mov BYTE PTR [esi],pad

 0000076C			nextPart:
 0000076C  80 3B 00			cmp BYTE PTR [ebx],0
 0000076F  74 02			je ePad
 00000771  EB 05			jmp nextPad
 00000773				ePad:
 00000773  C6 03 5F				mov BYTE PTR [ebx],pad
 00000776  EB 00				jmp nextPad
 00000778				nextpad:
 00000778  46					inc esi
 00000779  43					inc ebx
 0000077A  E2 E6				loop addPads

 0000077C			encryptionDone:
 0000077C  8B E5		    mov esp,ebp
 0000077E  5D			    pop ebp
 0000077F  C3			    ret
 00000780			encryptText ENDP

				;----------------------------------------------------------
 00000780			decryptText PROC
				;	Decrypt using Columnar Transposition Cipher algorithm
				;	
				;	Input:		oText
				;               eText
				;               key
				;               keyLength
				;               bytesRead
				;	Output:		eText
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
 = DWORD PTR [ebp-4]		    oTextEnd EQU DWORD PTR [ebp-4]
 = DWORD PTR [ebp-8]		    rowCount EQU DWORD PTR [ebp-8]
 = DWORD PTR [ebp-12]		    padCount EQU DWORD PTR [ebp-12]
 = DWORD PTR [ebp-16]		    keyPTR EQU DWORD PTR [ebp-16]       ;address to start of key
 = DWORD PTR [ebp-20]		    col0 EQU DWORD PTR [ebp-20]        ;address to col0
 = DWORD PTR [ebp-24]		    col1 EQU DWORD PTR [ebp-24] 
 = DWORD PTR [ebp-28]		    col2 EQU DWORD PTR [ebp-28] 
 = DWORD PTR [ebp-32]		    col3 EQU DWORD PTR [ebp-32] 
 = DWORD PTR [ebp-36]		    col4 EQU DWORD PTR [ebp-36] 
 = DWORD PTR [ebp-40]		    col5 EQU DWORD PTR [ebp-40] 
 = DWORD PTR [ebp-44]		    col6 EQU DWORD PTR [ebp-44] 
 = DWORD PTR [ebp-48]		    col7 EQU DWORD PTR [ebp-48] 
 = DWORD PTR [ebp-52]		    col8 EQU DWORD PTR [ebp-52] 
 = DWORD PTR [ebp-56]		    col9 EQU DWORD PTR [ebp-56]
 = DWORD PTR [ebp-60]		    cOrder0 EQU DWORD PTR [ebp-60]
 = DWORD PTR [ebp-100]		    count EQU DWORD PTR [ebp-100]
 = BYTE PTR [ebp-104]		    lower EQU BYTE PTR [ebp-104]
 = BYTE PTR [ebp-108]		    upper EQU BYTE PTR [ebp-108]
 = DWORD PTR [ebp-112]		    index EQU DWORD PTR [ebp-112]
 = DWORD PTR [ebp-116]		    temp1 EQU DWORD PTR [ebp-116]

 00000780  55			    push ebp
 00000781  8B EC		    mov ebp,esp
 00000783  83 EC 74		    sub esp,116           ;29 local DWORDs

				;wipe local variables
 00000786  B9 0000001D			mov ecx,29
 0000078B  8D 75 FC			lea esi,oTextEnd
 0000078E			wipe:
 0000078E  C7 06 00000000		mov DWORD PTR [esi],0
 00000794  83 EE 04			sub esi,4
 00000797  E2 F5			loop wipe

				;calculate rowCount & padCount at the end of the oText
 00000799  BA 00000000			mov edx,0
 0000079E  A1 00003A08 R		mov eax,bytesRead  
 000007A3  8B 0D 00003A2C R		mov ecx,keyLength
 000007A9  F7 F1			div ecx
 000007AB  83 FA 00			cmp edx,0
 000007AE  77 0C			ja Padding
 000007B0  C7 45 F4			mov padCount,0
	   00000000
 000007B7  89 45 F8			mov rowCount,eax
 000007BA  EB 09			jmp NoPadding

 000007BC			Padding:
 000007BC  2B CA			sub ecx,edx
 000007BE  89 4D F4			mov padCount,ecx
 000007C1  40				inc eax
 000007C2  89 45 F8			mov rowCount,eax

 000007C5			NoPadding:

				;get keyPTR
 000007C5  BE 00003A22 R		mov esi,OFFSET key
 000007CA  B8 0000000A			mov eax,10
 000007CF  2B 05 00003A2C R		sub eax,keyLength
 000007D5  03 F0			add esi,eax
 000007D7  89 75 F0			mov keyPTR,esi

					; mov eax,bytesRead
					; call WriteDec
					; call Crlf
					; mov eax,rowCount
					; call WriteDec
					; call Crlf
					; mov eax,padCount
					; call WriteDec
					; call Crlf

				;break up the encrypted eText into columns
				;store address for each column in col0 - col9
 000007DA  8B 0D 00003A2C R		mov ecx,keyLength
 000007E0  B8 000016DD R		mov eax,OFFSET eText
 000007E5  8B F5			mov esi,ebp				;col0
 000007E7  83 EE 14			sub esi,20
 000007EA			colLoop:
 000007EA  89 06			mov DWORD PTR [esi],eax
 000007EC  03 45 F8			add eax,rowCount
 000007EF  83 EE 04			sub esi,4
 000007F2  E2 F6			loop colLoop

				;macro to get column order address based on index
				goCol MACRO
					push eax
					push edx
					mov esi,ebp				;cOrder0
					sub esi,60
					mov eax,index
					mov edx,4
					mul edx
					sub esi,eax
					pop edx
					pop eax
				ENDM

 000007F4  C6 45 98 7B			mov lower,123
 000007F8  8B 0D 00003A2C R		mov ecx,keyLength
 000007FE  C7 45 9C			mov count,1
	   00000001
 00000805			sortL1:
 00000805  51				push ecx
 00000806  C6 45 98 7B			mov lower,123
 0000080A  8B 0D 00003A2C R		mov ecx,keyLength
 00000810  8B 7D F0			mov edi,keyPTR						;keyPTR
 00000813  C7 45 90			mov index,0							;current key position
	   00000000
 0000081A				sortL2:
						;check if column order is empty
						goCol							;go to current column order
 0000081A  50		     1		push eax
 0000081B  52		     1		push edx
 0000081C  8B F5	     1		mov esi,ebp				;cOrder0
 0000081E  83 EE 3C	     1		sub esi,60
 00000821  8B 45 90	     1		mov eax,index
 00000824  BA 00000004	     1		mov edx,4
 00000829  F7 E2	     1		mul edx
 0000082B  2B F0	     1		sub esi,eax
 0000082D  5A		     1		pop edx
 0000082E  58		     1		pop eax
 0000082F  83 3E 00				cmp DWORD PTR [esi],0
 00000832  77 26				ja nextChar                     ;this char already has an order

 00000834  8A 45 98				mov al,lower
 00000837  38 07				cmp BYTE PTR [edi],al
 00000839  72 02				jb foundLower
 0000083B  EB 1D				jmp nextChar

 0000083D				foundLower:
 0000083D  8A 07				mov al,BYTE PTR [edi]
 0000083F  88 45 98				mov lower,al                    ;store the new lowest ascii
						goCol                           ;go to current column order
 00000842  50		     1		push eax
 00000843  52		     1		push edx
 00000844  8B F5	     1		mov esi,ebp				;cOrder0
 00000846  83 EE 3C	     1		sub esi,60
 00000849  8B 45 90	     1		mov eax,index
 0000084C  BA 00000004	     1		mov edx,4
 00000851  F7 E2	     1		mul edx
 00000853  2B F0	     1		sub esi,eax
 00000855  5A		     1		pop edx
 00000856  58		     1		pop eax
 00000857  89 75 8C				mov temp1,esi                   ;remember the current column

 0000085A				nextChar:
 0000085A  FF 45 90				inc index
 0000085D  47					inc edi

 0000085E				continue:
 0000085E  E2 BA				loop sortL2

					;mov count to the column
 00000860  8B 45 9C			mov eax,count
 00000863  8B 75 8C			mov esi,temp1
 00000866  89 06			mov DWORD PTR [esi],eax

 00000868  59				pop ecx
 00000869  FF 45 9C			inc count
 0000086C  E2 97			loop sortL1

				comment !
				Example:
					key =    H A C K K A
					order =  4 1 3 5 6 2
					keyLength = 6

					Encryption:
						"I did not buy anything this Black Friday because I do not have any money"
						 413562413562413562413562413562413562413562413562413562413562413562413562

					Decryption:  rowCount = 72 / 6 = 12
						" O IICDCIOEM UTTLRBE AYYDTANSKAA T OINYHHAIE NV I NG  YUD ANDBY BF SOHNE"
						 <-  col 1 -><-  col 2 -><-  col 3 -><-  col 4 -><-  col 5 -><-  col 6 ->

						 1st row: 413562 -> take 1st character from each column -> "I_DID_"
						 2nd row: 413562 -> take 2nd character from each column -> "NOT_BU"
						 3rd row: same ...
				!

				;esi  -> oText		edi  -> order		edx  -> column
 0000086E  C7 45 9C			mov count,1
	   00000001
 00000875  8D 35 00000B24 R		lea esi,oText
 0000087B  8D 7D C4			lea edi,cOrder0
 0000087E  B9 00000001			mov ecx,1

 00000883			readeText:
 00000883  8B 45 9C			mov eax,count
 00000886  3B 05 00003A08 R		cmp eax,bytesRead
 0000088C  77 36			ja endOfeText
 0000088E  8D 55 EC			lea edx,col0
 00000891  3B 0D 00003A2C R		cmp ecx,keyLength
 00000897  77 02			ja Reorder
 00000899  EB 08			jmp writeoText

 0000089B			Reorder:
 0000089B  B9 00000001			mov ecx,1
 000008A0  8D 7D C4			lea edi,cOrder0
 000008A3			writeoText:
 000008A3  8B 07			mov eax,DWORD PTR [edi]
 000008A5  48				dec eax
 000008A6  52				push edx
 000008A7  BA 00000004			mov edx,4
 000008AC  F7 E2			mul edx
 000008AE  5A				pop edx
 000008AF  2B D0			sub edx,eax                     ;go to the correct column
 000008B1  8B 02			mov eax,DWORD PTR [edx]         ;address to the position in eText
 000008B3  8A 18			mov bl,BYTE PTR [eax]           ;get the character
 000008B5  88 1E			mov BYTE PTR[esi],bl            ;write to oText
 000008B7  40				inc eax                         ;point to the next char in column
 000008B8  89 02			mov DWORD PTR [edx],eax         ;update column address

 000008BA  83 EF 04			sub edi,4                       ;next order number
 000008BD  46				inc esi                         ;next char in oText
 000008BE  41				inc ecx                         ;keyLength counter
 000008BF  FF 45 9C			inc count
 000008C2  EB BF			jmp readeText

 000008C4			endOfeText:
 000008C4  8B E5		    mov esp,ebp
 000008C6  5D			    pop ebp
 000008C7  C3			    ret
 000008C8			decryptText ENDP

				;--------------------------------
 000008C8			bruteForce PROC
				;
				;	
				;	Input:		None
				;	Output:		None
				;	Require:	Irvine32.inc
				;----------------------------------------------------------
 = DWORD PTR [ebp-8]			PTRBkey EQU DWORD PTR [ebp-8]
 000008C8  55				push ebp
 000008C9  8B EC		    mov ebp,esp
 000008CB  83 EC 08		    sub esp,8           ;2 local DWORD

 000008CE  B9 0000000A			mov ecx,10
 000008D3  89 0D 00003A1E R		mov BkeyLength,ecx
 000008D9  C7 45 F8		    mov PTRBkey,OFFSET Bkey
	   00003A14 R
 000008E0  83 45 F8 09		    add PTRBkey,9

 000008E4			fillBkey:
 000008E4  8B 75 F8			mov esi,DWORD PTR [PTRBkey]
 000008E7  C6 06 30		    mov BYTE PTR [esi],48
 000008EA  FF 4D F8		    dec PTRBkey
 000008ED  E2 F5			loop fillBkey

				;generate key from 10000, +1 at a time
 000008EF  C7 05 00003A43 R		mov Bcount,10000
	   00002710
 000008F9			serialKeyGen:
 000008F9  BE 00003A14 R		mov esi,OFFSET Bkey
 000008FE  83 C6 09		    add esi,9
 00000901  FF 05 00003A43 R		inc Bcount
 00000907  A1 00003A43 R		mov eax,Bcount
 0000090C  BB 0000000A			mov ebx,10
 00000911  B9 0000000A			mov ecx,10
				;convert integer key to string key
 00000916			toStr:
 00000916  BA 00000000			mov edx,0
 0000091B  F7 F3			div ebx
 0000091D  83 C2 30			add edx,48
 00000920  88 16			mov BYTE PTR [esi],dl
 00000922  4E				dec esi
 00000923  E2 F1			loop toStr

					;testing, just comparing to 12345
					;cmp Bcount,12345
					;je foundKey
					;jmp serialKeyGen

				;copy Bkey to key
 00000925  B9 0000000A			mov ecx,10
 0000092A  BE 00003A22 R		mov esi,OFFSET key
 0000092F  BF 00003A14 R		mov edi,OFFSET Bkey
 00000934			copyKey:
 00000934  8A 07			mov al,BYTE PTR [edi]
 00000936  88 06			mov BYTE PTR [esi],al
 00000938  46				inc esi
 00000939  47				inc edi
 0000093A  E2 F8			loop copyKey

				;calculate keyLength
 0000093C  C7 05 00003A2C R		mov keyLength,5
	   00000005
 00000946  81 3D 00003A43 R		cmp Bcount,999999999
	   3B9AC9FF
 00000950  77 32			ja @10
 00000952  81 3D 00003A43 R		cmp Bcount,99999999
	   05F5E0FF
 0000095C  77 32			ja @9
 0000095E  81 3D 00003A43 R		cmp Bcount,9999999
	   0098967F
 00000968  77 32			ja @8
 0000096A  81 3D 00003A43 R		cmp Bcount,999999
	   000F423F
 00000974  77 32			ja @7
 00000976  81 3D 00003A43 R		cmp Bcount,99999
	   0001869F
 00000980  77 32			ja @6
 00000982  EB 3A			jmp check
 00000984			@10:
 00000984  C7 05 00003A2C R		mov keyLength,10
	   0000000A
 0000098E  EB 2E			jmp Check
 00000990			@9:
 00000990  C7 05 00003A2C R		mov keyLength,9
	   00000009
 0000099A  EB 22			jmp Check
 0000099C			@8:
 0000099C  C7 05 00003A2C R		mov keyLength,8
	   00000008
 000009A6  EB 16			jmp Check
 000009A8			@7:
 000009A8  C7 05 00003A2C R		mov keyLength,7
	   00000007
 000009B2  EB 0A			jmp Check
 000009B4			@6:
 000009B4  C7 05 00003A2C R		mov keyLength,6
	   00000006

				;check if key is correct by decryption	
 000009BE			Check:
 000009BE  E8 FFFFFDBD			call decryptText
 000009C3  BB 00000000			mov ebx,0
 000009C8  8D 35 00000B24 R		lea esi,oText
 000009CE  8D 3D 00002296 R		lea edi,BoText
 000009D4  B0 00			mov al,0				;comparison score, 0 = match
 000009D6  B9 0000000A			mov ecx,10				;only checking the first 20 characters
 000009DB			LoopOne:
 000009DB  02 06			add al,BYTE PTR [esi]	;move ascii code from BoText
 000009DD  2A 07			sub al,BYTE PTR [edi]	;if BoText = BeText, al = 0 here
 000009DF  3C 00			cmp al,0
 000009E1  74 01			je Same
 000009E3  43				inc ebx
 000009E4			Same:
 000009E4  46				inc esi
 000009E5  47				inc edi
 000009E6  E2 F3			loop LoopOne

 000009E8  83 FB 00			cmp ebx,0
 000009EB  74 05			je foundKey				;al = 0 means BoText = BeText for all 20 characters
 000009ED  E9 FFFFFF07			jmp serialKeyGen				;al != 0, we need to guess key again

 000009F2			foundKey:
					printStr msg3_3
 000009F2  52		     1	    push edx
 000009F3  BA 00000A7C R     1	    mov edx,OFFSET msg3_3
 000009F8  E8 00000000 E     1	    call WriteString
 000009FD  5A		     1	    pop edx

 000009FE  BB 0000000A		    mov ebx,10
 00000A03  2B 1D 00003A2C R	    sub ebx,keyLength
 00000A09  BE 00003A14 R	    mov esi,OFFSET Bkey
 00000A0E  03 F3		    add esi,ebx
 00000A10  8B 0D 00003A2C R	    mov ecx,keyLength
 00000A16			printLoop:
 00000A16  8A 06		    mov al,BYTE PTR [esi]
 00000A18  FE C0			inc al
 00000A1A  E8 00000000 E	    call WriteChar
 00000A1F  83 C6 01		    add esi,1
 00000A22  E2 F2		    loop printLoop

 00000A24  8B E5			mov esp,ebp
 00000A26  5D			    pop ebp
 00000A27  C3				ret
 00000A28			bruteForce ENDP


				;function to open a text file and read it to oText
				;experiment with passing by reference
				;just need to do [push OFFSET <your text>] before calling this proc
 00000A28			readText PROC
 00000A28  55			    push ebp
 00000A29  8B EC		    mov ebp,esp
 00000A2B  8B 55 08		    mov edx,[ebp + 8]           ;pass by reference
 00000A2E  E8 00000000 E		call OpenInputFIle
 00000A33  A3 00003A10 R		mov fileHandle,eax
 00000A38  8B 55 0C			mov edx,[ebp + 12]
 00000A3B  B9 00000BB8			mov ecx,textSize
 00000A40  E8 00000000 E		call ReadFromFile
 00000A45  A3 00003A08 R		mov bytesRead,eax
 00000A4A  A1 00003A10 R		mov eax,fileHandle
 00000A4F  E8 00000000 E		call CloseFile
 00000A54  5D			    pop ebp
 00000A55  C2 0008		    ret 8						;only pass 1 DWORD
 00000A58			readText ENDP

				;push source and then destination file name
 00000A58			writeText PROC
 00000A58  55			    push ebp
 00000A59  8B EC		    mov ebp,esp
 00000A5B  8B 55 08		    mov edx,[ebp + 8] 
 00000A5E  E8 00000000 E		call CreateOutputFile
 00000A63  A3 00003A10 R		mov fileHandle, eax
 00000A68  8B 55 0C			mov edx,[ebp + 12]
 00000A6B  8B 0D 00003A08 R		mov ecx,bytesRead
 00000A71  E8 00000000 E		call WriteToFile
 00000A76  A1 00003A10 R		mov eax, fileHandle
 00000A7B  E8 00000000 E		call CloseFile
 00000A80  5D			    pop ebp
 00000A81  C2 0008		    ret 8						;passed 2 DWORDs
 00000A84			writeText ENDP

				;function to print a text
				;just need to do [push OFFSET <your text>]  before calling this proc
 00000A84			printText PROC
 00000A84  55			    push ebp
 00000A85  8B EC		    mov ebp,esp
 00000A87  8B 75 08		    mov esi,[ebp + 8]           ;pass by reference
 00000A8A  8B 0D 00003A08 R		mov ecx,bytesRead
 00000A90  E8 00000000 E	    call Crlf
 00000A95  E8 00000000 E	    call Crlf
 00000A9A  E8 00000000 E	    call Crlf
 00000A9F			printIt:
 00000A9F  8A 06			mov al,BYTE PTR [esi]
 00000AA1  E8 00000000 E		call WriteChar
 00000AA6  46				inc esi
 00000AA7  E2 F6			loop printIt
 00000AA9  E8 00000000 E	    call Crlf
 00000AAE  E8 00000000 E	    call Crlf
 00000AB3  E8 00000000 E	    call Crlf
 00000AB8  5D			    pop ebp
 00000AB9  C2 0004		    ret 4
 00000ABC			printText ENDP

				;wipe oText and eText
 00000ABC			wipeText PROC
 00000ABC  83 3D 00003A08 R		cmp bytesRead,0
	   00
 00000AC3  74 1A			je nothing2Wipe
 00000AC5  8B 0D 00003A08 R		mov ecx,bytesRead
 00000ACB  BE 00000B24 R		mov esi,OFFSET oText
 00000AD0  BB 000016DD R		mov ebx,OFFSET eText
 00000AD5			clean:
 00000AD5  C6 06 00			mov BYTE PTR [esi],0
 00000AD8  C6 03 00			mov BYTE PTR [ebx],0
 00000ADB  46				inc esi
 00000ADC  43				inc ebx
 00000ADD  E2 F6			loop clean
 00000ADF			nothing2Wipe:
 00000ADF  B9 00000000			mov ecx,0
 00000AE4  BE 00000000			mov esi,0
 00000AE9  BB 00000000			mov ebx,0
 00000AEE  C3				ret
 00000AEF			wipeText ENDP

				;wipe key and related memory locations
 00000AEF			wipeKey PROC
 00000AEF  C7 05 00003A2C R		mov keyLength,0
	   00000000
 00000AF9  C7 05 00003A30 R		mov keyType,0
	   00000000
 00000B03  B9 0000000A			mov ecx,10
 00000B08  8D 35 00003A22 R		lea esi,key
 00000B0E  8D 1D 00003A38 R		lea ebx,keyInput
 00000B14			WKL:
 00000B14  C6 06 00			mov BYTE PTR [esi],0
 00000B17  C6 03 00			mov BYTE PTR [ebx],0
 00000B1A  46				inc esi
 00000B1B  43				inc ebx
 00000B1C  E2 F6			loop WKL
 00000B1E  BE 00000000			mov esi,0
 00000B23  BB 00000000			mov ebx,0
 00000B28  C3				ret
 00000B29			wipeKey ENDP
				end main
Microsoft (R) Macro Assembler Version 14.22.27905.0	    01/23/20 14:19:56
final_project.asm					     Symbols 2 - 1




Macros:

                N a m e                 Type

goCol  . . . . . . . . . . . . .	Proc
printStr . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00003A47 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000B29 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
bruteForce . . . . . . . . . . .	P Near	 000008C8 _TEXT	Length= 00000160 Public STDCALL
  fillBkey . . . . . . . . . . .	L Near	 000008E4 _TEXT	
  serialKeyGen . . . . . . . . .	L Near	 000008F9 _TEXT	
  toStr  . . . . . . . . . . . .	L Near	 00000916 _TEXT	
  copyKey  . . . . . . . . . . .	L Near	 00000934 _TEXT	
  @10  . . . . . . . . . . . . .	L Near	 00000984 _TEXT	
  @9 . . . . . . . . . . . . . .	L Near	 00000990 _TEXT	
  @8 . . . . . . . . . . . . . .	L Near	 0000099C _TEXT	
  @7 . . . . . . . . . . . . . .	L Near	 000009A8 _TEXT	
  @6 . . . . . . . . . . . . . .	L Near	 000009B4 _TEXT	
  Check  . . . . . . . . . . . .	L Near	 000009BE _TEXT	
  LoopOne  . . . . . . . . . . .	L Near	 000009DB _TEXT	
  Same . . . . . . . . . . . . .	L Near	 000009E4 _TEXT	
  foundKey . . . . . . . . . . .	L Near	 000009F2 _TEXT	
  printLoop  . . . . . . . . . .	L Near	 00000A16 _TEXT	
decryptText  . . . . . . . . . .	P Near	 00000780 _TEXT	Length= 00000148 Public STDCALL
  wipe . . . . . . . . . . . . .	L Near	 0000078E _TEXT	
  Padding  . . . . . . . . . . .	L Near	 000007BC _TEXT	
  NoPadding  . . . . . . . . . .	L Near	 000007C5 _TEXT	
  colLoop  . . . . . . . . . . .	L Near	 000007EA _TEXT	
  sortL1 . . . . . . . . . . . .	L Near	 00000805 _TEXT	
  sortL2 . . . . . . . . . . . .	L Near	 0000081A _TEXT	
  foundLower . . . . . . . . . .	L Near	 0000083D _TEXT	
  nextChar . . . . . . . . . . .	L Near	 0000085A _TEXT	
  continue . . . . . . . . . . .	L Near	 0000085E _TEXT	
  readeText  . . . . . . . . . .	L Near	 00000883 _TEXT	
  Reorder  . . . . . . . . . . .	L Near	 0000089B _TEXT	
  writeoText . . . . . . . . . .	L Near	 000008A3 _TEXT	
  endOfeText . . . . . . . . . .	L Near	 000008C4 _TEXT	
encryptText  . . . . . . . . . .	P Near	 000005D9 _TEXT	Length= 000001A7 Public STDCALL
  wipe . . . . . . . . . . . . .	L Near	 000005E6 _TEXT	
  Padding  . . . . . . . . . . .	L Near	 00000614 _TEXT	
  NoPadding  . . . . . . . . . .	L Near	 0000061D _TEXT	
  colLoop  . . . . . . . . . . .	L Near	 00000642 _TEXT	
  sortL1 . . . . . . . . . . . .	L Near	 0000065D _TEXT	
  sortL2 . . . . . . . . . . . .	L Near	 00000672 _TEXT	
  foundLower . . . . . . . . . .	L Near	 00000695 _TEXT	
  nextChar . . . . . . . . . . .	L Near	 000006B2 _TEXT	
  continue . . . . . . . . . . .	L Near	 000006B6 _TEXT	
  testL1 . . . . . . . . . . . .	L Near	 000006DB _TEXT	
  readoText  . . . . . . . . . .	L Near	 00000707 _TEXT	
  Reorder  . . . . . . . . . . .	L Near	 0000071D _TEXT	
  writeeText . . . . . . . . . .	L Near	 00000727 _TEXT	
  endOfoText . . . . . . . . . .	L Near	 00000743 _TEXT	
  addPads  . . . . . . . . . . .	L Near	 00000762 _TEXT	
  oPad . . . . . . . . . . . . .	L Near	 00000769 _TEXT	
  nextPart . . . . . . . . . . .	L Near	 0000076C _TEXT	
  ePad . . . . . . . . . . . . .	L Near	 00000773 _TEXT	
  nextpad  . . . . . . . . . . .	L Near	 00000778 _TEXT	
  encryptionDone . . . . . . . .	L Near	 0000077C _TEXT	
enterKey . . . . . . . . . . . .	P Near	 000003A4 _TEXT	Length= 0000006D Public STDCALL
  Start  . . . . . . . . . . . .	L Near	 000003A4 _TEXT	
  keyOkay  . . . . . . . . . . .	L Near	 000003D3 _TEXT	
  copyKey  . . . . . . . . . . .	L Near	 000003F7 _TEXT	
generateKey  . . . . . . . . . .	P Near	 00000506 _TEXT	Length= 000000AE Public STDCALL
  L1 . . . . . . . . . . . . . .	L Near	 00000559 _TEXT	
  alphabets  . . . . . . . . . .	L Near	 0000056B _TEXT	
  lowercase1 . . . . . . . . . .	L Near	 00000573 _TEXT	
  Next1  . . . . . . . . . . . .	L Near	 00000575 _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 0000057C _TEXT	
  lowercase2 . . . . . . . . . .	L Near	 0000058E _TEXT	
  Next2  . . . . . . . . . . . .	L Near	 00000590 _TEXT	
  L3 . . . . . . . . . . . . . .	L Near	 00000597 _TEXT	
  numbers  . . . . . . . . . . .	L Near	 000005A9 _TEXT	
  Next3  . . . . . . . . . . . .	L Near	 000005AB _TEXT	
  Finish . . . . . . . . . . . .	L Near	 000005B0 _TEXT	
keyOption  . . . . . . . . . . .	P Near	 00000382 _TEXT	Length= 00000022 Public STDCALL
  userEnterKey . . . . . . . . .	L Near	 0000039E _TEXT	
  keyDone  . . . . . . . . . . .	L Near	 000003A3 _TEXT	
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000089 Public STDCALL
  Start  . . . . . . . . . . . .	L Near	 0000000F _TEXT	
  O1 . . . . . . . . . . . . . .	L Near	 00000043 _TEXT	
  O2 . . . . . . . . . . . . . .	L Near	 0000004A _TEXT	
  O3 . . . . . . . . . . . . . .	L Near	 00000051 _TEXT	
  O8 . . . . . . . . . . . . . .	L Near	 00000058 _TEXT	
  Finish . . . . . . . . . . . .	L Near	 00000078 _TEXT	
option1  . . . . . . . . . . . .	P Near	 00000089 _TEXT	Length= 00000193 Public STDCALL
  O1Start  . . . . . . . . . . .	L Near	 00000089 _TEXT	
  O1_1 . . . . . . . . . . . . .	L Near	 000000E0 _TEXT	
  O1_2 . . . . . . . . . . . . .	L Near	 0000014A _TEXT	
  O1_3 . . . . . . . . . . . . .	L Near	 000001B1 _TEXT	
  O1Finish . . . . . . . . . . .	L Near	 00000216 _TEXT	
  O1Return . . . . . . . . . . .	L Near	 0000021B _TEXT	
option2  . . . . . . . . . . . .	P Near	 0000021C _TEXT	Length= 000000F6 Public STDCALL
  O2Start  . . . . . . . . . . .	L Near	 0000021C _TEXT	
  O2_1 . . . . . . . . . . . . .	L Near	 000002B6 _TEXT	
  goOn . . . . . . . . . . . . .	L Near	 000002CD _TEXT	
  O2_2 . . . . . . . . . . . . .	L Near	 00000305 _TEXT	
  O2Finish . . . . . . . . . . .	L Near	 0000030C _TEXT	
  O2Return . . . . . . . . . . .	L Near	 00000311 _TEXT	
option3  . . . . . . . . . . . .	P Near	 00000312 _TEXT	Length= 00000070 Public STDCALL
  O3Start  . . . . . . . . . . .	L Near	 00000312 _TEXT	
  O3Finish . . . . . . . . . . .	L Near	 0000037C _TEXT	
  O3Return . . . . . . . . . . .	L Near	 00000381 _TEXT	
pickKey  . . . . . . . . . . . .	P Near	 00000411 _TEXT	Length= 000000F5 Public STDCALL
  Start  . . . . . . . . . . . .	L Near	 00000411 _TEXT	
  InvalidLength  . . . . . . . .	L Near	 0000042C _TEXT	
  Next . . . . . . . . . . . . .	L Near	 0000043A _TEXT	
  L  . . . . . . . . . . . . . .	L Near	 0000043F _TEXT	
  N1 . . . . . . . . . . . . . .	L Near	 00000476 _TEXT	
  N2 . . . . . . . . . . . . . .	L Near	 00000499 _TEXT	
  N3 . . . . . . . . . . . . . .	L Near	 000004BC _TEXT	
  N4 . . . . . . . . . . . . . .	L Near	 000004C5 _TEXT	
  Done . . . . . . . . . . . . .	L Near	 000004F4 _TEXT	
  emptyKey . . . . . . . . . . .	L Near	 000004F5 _TEXT	
printKey . . . . . . . . . . . .	P Near	 000005B4 _TEXT	Length= 00000025 Public STDCALL
  printLoop  . . . . . . . . . .	L Near	 000005CC _TEXT	
printText  . . . . . . . . . . .	P Near	 00000A84 _TEXT	Length= 00000038 Public STDCALL
  printIt  . . . . . . . . . . .	L Near	 00000A9F _TEXT	
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
readText . . . . . . . . . . . .	P Near	 00000A28 _TEXT	Length= 00000030 Public STDCALL
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wipeKey  . . . . . . . . . . . .	P Near	 00000AEF _TEXT	Length= 0000003A Public STDCALL
  WKL  . . . . . . . . . . . . .	L Near	 00000B14 _TEXT	
wipeText . . . . . . . . . . . .	P Near	 00000ABC _TEXT	Length= 00000033 Public STDCALL
  clean  . . . . . . . . . . . .	L Near	 00000AD5 _TEXT	
  nothing2Wipe . . . . . . . . .	L Near	 00000ADF _TEXT	
writeText  . . . . . . . . . . .	P Near	 00000A58 _TEXT	Length= 0000002C Public STDCALL
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
Bcount . . . . . . . . . . . . .	DWord	 00003A43 _DATA	
BeText . . . . . . . . . . . . .	Byte	 00002E4F _DATA	
BkeyLength . . . . . . . . . . .	DWord	 00003A1E _DATA	
Bkey . . . . . . . . . . . . . .	Byte	 00003A14 _DATA	
BoText . . . . . . . . . . . . .	Byte	 00002296 _DATA	
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PTRBkey  . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-8]
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
base . . . . . . . . . . . . . .	DWord	 00003A34 _DATA	
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
bytesRead  . . . . . . . . . . .	DWord	 00003A08 _DATA	
bytesWritten . . . . . . . . . .	DWord	 00003A0C _DATA	
cOrder0  . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-60]
col0 . . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-20]
col1 . . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-24]
col2 . . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-28]
col3 . . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-32]
col4 . . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-36]
col5 . . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-40]
col6 . . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-44]
col7 . . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-48]
col8 . . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-52]
col9 . . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-56]
count  . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-100]
cyan . . . . . . . . . . . . . .	Number	 00000003h   
eText  . . . . . . . . . . . . .	Byte	 000016DD _DATA	
err1_0 . . . . . . . . . . . . .	Byte	 0000054D _DATA	
err1_1 . . . . . . . . . . . . .	Byte	 00000561 _DATA	
err1_2 . . . . . . . . . . . . .	Byte	 00000570 _DATA	
err2_0 . . . . . . . . . . . . .	Byte	 00000714 _DATA	
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
fileHandle . . . . . . . . . . .	DWord	 00003A10 _DATA	
fileName0  . . . . . . . . . . .	Byte	 00000ABB _DATA	
fileName1  . . . . . . . . . . .	Byte	 00000ACF _DATA	
fileName2  . . . . . . . . . . .	Byte	 00000AE8 _DATA	
fileNameBD . . . . . . . . . . .	Byte	 00000B14 _DATA	
fileNameBE . . . . . . . . . . .	Byte	 00000B04 _DATA	
fileNameD  . . . . . . . . . . .	Byte	 00000AA8 _DATA	
fileNameE  . . . . . . . . . . .	Byte	 00000A95 _DATA	
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
index  . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-112]
keyInput . . . . . . . . . . . .	Byte	 00003A38 _DATA	
keyLength  . . . . . . . . . . .	DWord	 00003A2C _DATA	
keyPTR . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-16]
keyType  . . . . . . . . . . . .	DWord	 00003A30 _DATA	
key  . . . . . . . . . . . . . .	Byte	 00003A22 _DATA	
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
lower  . . . . . . . . . . . . .	Text   	 BYTE PTR [ebp-104]
magenta  . . . . . . . . . . . .	Number	 00000005h   
msg0_1 . . . . . . . . . . . . .	Byte	 00000000 _DATA	
msg0_2 . . . . . . . . . . . . .	Byte	 000002D5 _DATA	
msg1_0 . . . . . . . . . . . . .	Byte	 000002E5 _DATA	
msg1_10  . . . . . . . . . . . .	Byte	 00000530 _DATA	
msg1_11  . . . . . . . . . . . .	Byte	 0000040F _DATA	
msg1_1 . . . . . . . . . . . . .	Byte	 00000319 _DATA	
msg1_2 . . . . . . . . . . . . .	Byte	 00000347 _DATA	
msg1_3 . . . . . . . . . . . . .	Byte	 0000037F _DATA	
msg1_4 . . . . . . . . . . . . .	Byte	 000003B7 _DATA	
msg1_5 . . . . . . . . . . . . .	Byte	 000003CB _DATA	
msg1_6 . . . . . . . . . . . . .	Byte	 000003DA _DATA	
msg1_7 . . . . . . . . . . . . .	Byte	 000004BD _DATA	
msg1_8 . . . . . . . . . . . . .	Byte	 000004DC _DATA	
msg1_9 . . . . . . . . . . . . .	Byte	 000004FC _DATA	
msg2_0 . . . . . . . . . . . . .	Byte	 00000587 _DATA	
msg2_1 . . . . . . . . . . . . .	Byte	 00000663 _DATA	
msg2_2 . . . . . . . . . . . . .	Byte	 00000683 _DATA	
msg2_3 . . . . . . . . . . . . .	Byte	 000006B7 _DATA	
msg2_4 . . . . . . . . . . . . .	Byte	 00000706 _DATA	
msg2_5 . . . . . . . . . . . . .	Byte	 000005DC _DATA	
msg2_6 . . . . . . . . . . . . .	Byte	 000005BC _DATA	
msg3_0 . . . . . . . . . . . . .	Byte	 0000072C _DATA	
msg3_1 . . . . . . . . . . . . .	Byte	 0000075E _DATA	
msg3_2 . . . . . . . . . . . . .	Byte	 000007CF _DATA	
msg3_3 . . . . . . . . . . . . .	Byte	 00000A7C _DATA	
oTextEnd . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-4]
oText  . . . . . . . . . . . . .	Byte	 00000B24 _DATA	
padCount . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-12]
pad  . . . . . . . . . . . . . .	Number	 0000005Fh   
red  . . . . . . . . . . . . . .	Number	 00000004h   
rowCount . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-8]
temp1  . . . . . . . . . . . . .	Text   	 DWORD PTR [ebp-116]
textSize . . . . . . . . . . . .	Number	 00000BB8h   
uniqueChar . . . . . . . . . . .	Text   	 DWORD PTR [ebp-4]
upper  . . . . . . . . . . . . .	Text   	 BYTE PTR [ebp-108]
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
